# 리액트 개발 도구로 디버깅하기

이번 장에서는 리액트로 개발된 애플리케이션의 디버깅을 돕기 위한 리액트 개발 도구인 `react-dev-tools`에 대해 살펴본다. 

## 리액트 개발 도구란?

리액트 팀은 리액트 앱의 원활한 개발을 위해 `react-dev-tools` 라는 개발 툴을 만들어 제공하고 있다. 이 개발 도구는 리액트로 만들어진 다양한 앱을 디버깅하기 위해 만들어졌다. 

이 도구를 웹 개발 환경에서 가장 편리하게 사용할 수 있는 방법은 브라우저 확장 프로그램을 사용하는 것이다. Chrome 기준 개발 도구를 설치하면 우측 상단 확장 도구 모음에 리액트 로고가 표시된다.

만약 **리액트 로고가 회색**으로 표시된다면, **리액트 개발 도구가 정상적으로 접근할 수 없는 페이지거나 리액트로 개발되지 않은 페이지**라는 뜻이다. 

**리액트 로고가 빨간색**으로 표시된다면, **개발 모드인 리액트 웹 앱에 정상적으로 리액트 개발 도구가 접근할 수 있다는 의미**다.

## 리액트 개발 도구 활용하기

리액트 개발 도구 설치 후 `개발자 도구`를 통해 두 가지 메뉴에 접근 가능하다.

- Components
- Profiler

### Components

Components 탭에서는 현재 리액트 앱의 컴포넌트 트리를 확인할 수 있다. 단순히 컴포넌트의 구조뿐만 아니라 props와 내부 hooks 등 다양한 정보를 확인 가능하다.

#### 컴포넌트 트리?

Components의 왼쪽 영역은 해당 리액트 페이지의 **컴포넌트 트리**를 나타낸다. 이름 그대로 트리 구조로 구성돼 있으며, 리액트 앱 전체의 트리 구조를 한 눈에 보여준다.

<img src="https://github.com/user-attachments/assets/56229130-97e6-4397-a43a-7491b3e29d20" width="600px" />

- 상단 입력란에서는 **정규식** 등을 활용해 검색할 수 있다.

```jsx
import { ComponentType, memo } from 'react';
import AnonymousDefaultComponent from './Component3';

function Component1() {
    return <>Component1</>
}

const Component2 = () => {
    return <>Component2</>
}

const MemoizedComponent = memo(() => <>MemoizedComponent</>);

const withSampleHOC = (Component : ComponentType) => {
    return function () {
        return <Component />
    }
}

const HOCComponent = withSampleHOC(() => <>HOCComponent</>);

export default function App() {
    return (
        <div className='App'>
            <Component1 />
            <Component2 />
            <AnonymousDefaultComponent />
            <MemoizedComponent />
            <HOCComponent />
        </div>
    )
}

// Component3.tsx
export default () => {
    return <>Components</>
}
```

위 예제를 실행하면 Component 탭에서 다음과 같이 확인할 수 있다.

<img src="https://github.com/user-attachments/assets/93511fca-b1a2-4822-aa8c-8e1b3292c8f7" width="600px" />

**기명 함수로 선언되어 컴포넌트명을 알 수 있다면 해당 컴포넌트명**을 보여주고, 만약 **익명 함수로 선언돼 있다면 Anonymous라는 이름으로 컴포넌트**를 보여준다.

즉, 함수 선언식(Function Declaration)과 함수 표현식(Function Expression)으로 생성한 컴포넌트는 모두 정상적으로 함수명을 표시한다. 그렇지 않은 컴포넌트는 다음과 같은 문제를 확인할 수 있다.

- 익명 함수를 default로 export한 AnonymousDefaultComponent의 경우 AnonymousDefualtComponent는 코드 내부에서 사용되는 이름일 뿐, 실제로 default export로 내보낸 함수의 명칭은 추론할 수 없다. 따라서 `default`로 표시된다.
- memo를 사용해 익명 함수로 만든 컴포넌트를 감쌀 경우, 함수명을 명확히 추론하지 못해서 Anonymous로 표시된다. `memo 라벨`을 통해 memo로 감싸진 컴포넌트임을 알 수 있다.
- 고차 컴포넌트인 withSampleHOC로 감싼 HOCComponent의 경우 두 가지 모두 Anonymous로 선언돼 있다.
- *단, 이는 16.8 버전에서의 이야기로, 이후 버전에서는 Anonymous 대신 _C3, _C5 등의 이름을 사용하는 등 일부 명칭 추론이 개선되었다. (위 이미지는 19버전)*

아래 코드처럼 익명 함수들을 기명 함수로 바꿔주면 Anonymous로 표시되는 문제가 해결된다.

```jsx
// 405페이지

import { ComponentType, memo } from 'react';
import AnonymousDefaultComponent from './Component3';

function Component1() {
    return <>Component1</>
}

const Component2 = () => {
    return <>Component2</>
}

const MemoizedComponent = memo(function MemoizedComponent() {
    return <>MemoizedComponent</>
});

const withSampleHOC = (Component : ComponentType) => {
    return function withSampleHOC () {
        return <Component />
    }
}

const HOCComponent = withSampleHOC(function HOCComponent() {
 return <>HOCComponent</>
});

export default function App() {
    return (
        <div className='App'>
            <Component1 />
            <Component2 />
            <AnonymousDefaultComponent />
            <MemoizedComponent />
            <HOCComponent />
        </div>
    )
}
```

<img src="https://github.com/user-attachments/assets/a26913ba-5de9-4be3-acfc-ef309f948c34" width="600px" />

함수를 기명함수로 바꾸기 어려운 경우에는 함수에 `displayName` 속성을 추가하는 방법도 있다. 

```jsx
const MemoizedComponent = memo(function () {
	return <>MemoizedComponent</>
});

MemoizedComponent.displayName = '메모 컴포넌트입니다.'
```

단, `Component.displayName`은 개발 모드에서 제한적으로만 사용하는게 좋다.

- 실제 서비스 중인 홈페이지의 컴포넌트 트리는 기명 함수로 선언되었다 하더라도 terser 등의 압축 도구 등이 컴포넌트명을 단순하게 난수화하기 때문에 확인이 어렵고, displayName은 빌드 도구가 사용하지 않는 코드로 인식해 삭제할 가능성이 있기 때문이다.

#### 컴포넌트명과 props

왼쪽 패널이 컴포넌트 트리였다면, 오른쪽에서는 해당 컴포넌트에 대한 자세한 정보가 주어진다.

<img src="https://github.com/user-attachments/assets/41be4b54-58ac-4de9-ab2c-845dde82554c" width="600px" />

- <1> 컴포넌트명과 Key
    - 컴포넌트명과 해당 컴포넌트의 Key 값을 확인할 수 있다. 회색 영역이 Key 이다.
    - Key는 `kidsValueProps`라는 객체다.
    - 빨간색 경고 이모티콘이 왼쪽에 붙는 경우도 있는데, 이는 **해당 앱이 `strict mode`로 렌더링되지 않았다는 것을 의미**한다.
- <2> 컴포넌트 도구
    - 3개의 아이콘이 있다.
    - 눈 모양 아이콘
        - 해당 컴포넌트가 HTML의 어디에서 렌더링됐는지 확인할 수 있다. 누르는 즉시 크롬 개발 도구 Element 탭으로 이동된다.
    - 벌레 아이콘
        - 눌러도 아무 일도 일어나지 않는 것처럼 보인다.
        - 클릭하는 순간 콘솔 탭에 해당 컴포넌트의 정보가 `console.log` 를 실행해 기록된 것을 확인할 수 있다.
        - 개발 도구 화면에서 보기 복잡하거나, 해당 정보를 복사하고 싶을 때 사용하면 좋다.
        - 해당 컴포넌트가 받는 `props`, 컴포넌트 내부에서 사용하는 `hooks`, 해당 컴포넌트의 HTML 요소인 `nodes`가 기록된다.
    - 소스코드 아이콘
        - 해당 컴포넌트의 소스 코드를 확인할 수 있다.
        - 하지만 소스 코드가 프로덕션 모드에서 빌드되어 최대로 압축돼있을 수 있어, 읽기 불편할 수 있다. 이럴 때는 좌측 하단의 `{}` 버튼을 클릭하면 코드를 적절히 포맷팅해준다.
        - 난독화된 코드를 읽고, 디버깅을 할 때 유용하다.
- <3> 컴포넌트 props
    - 해당 컴포넌트가 받은 props를 확인할 수 있다. 단순한 원시값뿐만 아니라 함수도 포함돼있다.
    - 우클릭을 하면 해당 props 정보를 복사하는 `Copy value to clipboard`와 `Store as global variable` 버튼이 나온다. 전자의 경우 클립보드로, 후자의 경우 `window.$r`에 해당 정보가 담긴다.
        - 후자를 선택 후 콘솔로 이동해보면 해당 변수에 대한 정보가 담겨 있는 것을 볼 수 있다.
    - 값이 함수인 props를 누르면 `Go to definition`이 나타난다. 이를 클릭하면 해당 함수가 선언된 코드로 이동한다. 더블클릭해 내용을 수정할 수도 있다. (???)
- <X> 컴포넌트 hooks
    - 위 예제에는 없지만 hooks 정보가 표시되는 섹션이 있다. 컴포넌트에서 사용 중인 훅 정보를 확인할 수 있다.
    - useState는 State와 같이 use가 생략된 이름으로 나타난다.
    - 다음은 리액트 개발자 도구에서 볼 수 있는 훅 목록이다.
        - State : useState
        - Reducer : useReducer
        - Context : useContext
        - Memo : useMemo
        - Callback : useCallback
        - Ref : useRef
        - id : useId
        - LayoutEffect : useLayoutEffect
        - Effect : useEffect
        - 이 외에 만약 리액트에서 정의되지 않은 명칭이 보인다면, 이는 **useXXX로 선언돼 있는 사용자 정의 훅**이다.
            - 훅에 넘겨주는 함수를 익명 대신 기명 함수로 넘겨주면 훅을 실행할 때 실행되는 함수 이름도 확인 가능하다.
            
            ```jsx
            // 함수 이름 확인 불가능
            useEffect(()=>{
            	console.log('useEffect');
            });
            
            // 함수 이름 확인 가능
            useEffect(function effectOnlyMount() {
            	console.log('useEffect');
            });
            ```
            

 

- <4> 컴포넌트를 렌더링한 주체, rendered by
    - `rendered by`는 해당 컴포넌트를 렌더링한 주체가 누구인지 확인할 수 있다.
    - 프로덕션 모드에서는 react-dom의 버전만 확인할 수 있다.
    - 개발 모드에서는 해당 컴포넌트를 렌더링한 부모 컴포넌트까지 확인할 수 있다.

### 프로파일러

컴포넌트 메뉴가 정적인 현재 리액트 컴포넌트 트리의 내용을 디버깅하기 위한 도구라면, **프로파일러는 리액트가 렌더링하는 과정에서 발생하는 상황을 확인하기 위한 도구**다. 

즉, 리액트 앱이 렌더링되는 과정에서 어떤 컴포넌트가 렌더링됐는지, 또 몇 차례나 렌더링이 일어났으며 어떤 작업에서 오래 걸렸는지 등 컴포넌트 렌더링 과정에서 발생하는 일을 확인할 수 있다.

- 프로파일링을 지원하지 않는 환경에서는 사용할 수 없다는 내용이 표시됨
- 렌더링 과정에 개입해 디버깅에 필요한 내용을 기록해야 하기 때문에, **프로덕션 빌드로 실행되는 리액트 앱에서는 사용할 수 없다.**

프로파일링을 위해 아래의 예제를 사용한다. 

```jsx
import { ChangeEvent, useEffect, useState } from 'react';

export default function App() {
    const [ text, setText ] = useState('');
    const [ number, setNumber ] = useState(0);
    const [ list, setList ] = useState([
        { name : 'apple', amount : 5000 },
        { name : 'apple', amount : 5000 },
        { name : 'apple', amount : 5000 },
        { name : 'apple', amount : 5000 },
    ]);

    useEffect(()=>{
        setTimeout(()=>{
            console.log('surprise!');
            setText('1000');
        }, 3000);
    });

    function handleTextChange(e : ChangeEvent<HTMLInputElement>) {
        setText(e.target.value);
    }

    function handleSubmit() {
        setList((prev) => [...prev, { name : text, amount : number}]);
    }

    function handleNumberChange(e : ChangeEvent<HTMLInputElement>) {
        setNumber(e.target.valueAsNumber);
    }

    return (
        <div>
            <input type='text' value={text} onChange={handleTextChange} />
            <button onClick={handleSubmit}>추가</button>

            <input type='number' value={number} onChange={handleNumberChange} />

            <ul>
                {
                    list.map((value, key)=>(
                        <li key={key}>
                            {value.name} {value.amount}원
                        </li>
                    ))}
            </ul>
        </div>
    );
}
```

#### 설정 변경하기

프로파일러의 Setting(톱니 아이콘)에는 몇가지 중요한 설정이 있다.

- General 탭 > Highlight updates when components render : 컴포넌트가 렌더링될 때마다 해당 컴포넌트에 하이라이트를 표시.
- Debugging 탭 > Hide logs during second render in Strict Mode : 리액트 앱이 엄격 모드에서 실행되는 경우, 원활한 디버깅을 위해 useEffect 등이 두 번씩 작동한다. 이를 막고 싶을 때 해당 버튼을 활성화시키면 된다.
- Profiler 탭 > Record why each component rendered while profiling : 프로파일링 도중 무엇 때문에 컴포넌트가 렌더링됐는지 기록한다. 앱 속도가 조금 느려질 수는 있지만 디버깅에 도움이 되는 옵션이므로 켜두는 것이 좋다.

#### 프로파일링

- 프로파일링 메뉴 : 리액트가 렌더링할 때 어떠한 일이 벌어지는 지 확인할 수 있는 도구다.
    
    ![image.png](attachment:48cb6c4d-d77e-4f97-a0f4-0f0cb7a54037:image.png)
    
    - Start Profiling(프로파일링 시작) : 프로파일링이 시작된다. 시작된 후 적색 동그라미로 바뀌며, 프로파일링 중이라는 메시지가 나타난다. 다시 누르면 프로파일링이 중단되고 결과가 나타난다.
    - Reload and Start profiling(새로고침 후 프로파일링 시작) : 첫 번째 버튼과 유사하지만, 웹페이지가 새로고침되면서 이와 동시에 프로파일링이 시작된다. 프로파일링 중단은 Start Profiling처럼 빨간 버튼을 클릭한다.
    - Stop Profiling(프로파일링 종료) : 프로파일링된 현재 내용을 모두 지우는 버튼이다. 프로파일링된 기록을 모두 삭제할 수 있다.
    - Load Profiling(프로파일 불러오기) : Save Profiling으로 저장한 프로파일링을 불러올 수 있다.
    - Save Profiling(프로파일 저장하기) : 프로파일링 결과를 저장하면 사용자의 브라우저에 해당 프로파일링 정보가 담긴 JSON 파일이 다운로드된다.
        - 이 JSON 파일은 단순히 리액트 개발 도구에서 저장하고 불러오는 용도의 파일이다. 직접 열어서 확인하기에는 어려운 구조다.
- Flamegraph
    - 불꽃 모양의 아이콘을 클릭하면 된다. 해당 탭에서는 렌더 커밋별로 어떠한 작업이 일어났는지 나타낸다. 너비가 넓을 수록 해당 컴포넌트를 렌더링하는 데 오래 걸렸다는 것을 의미한다.
        - 당연하게도, **렌더링이 가장 오래 걸리는 컴포넌트는 모든 컴포넌트를 렌더링해야 하는 루트 컴포넌트다.**
    - 각 컴포넌트에 마우스 커서를 가져다 대면 해당 컴포넌트의 렌더링과 관련된 정보를 확인할 수 있다.
        - 렌더링이 일어난 컴포넌트의 렌더링 정보, 해당 컴포넌트가 렌더링된 이유, 전체 렌더링에서 소요된 시간
    - 오른쪽에는 해당 커밋과 관련된 추가적인 정보를 확인할 수 있다.
        
        ![image.png](attachment:ab189576-d2ca-400d-a1fa-5b4fb5e96513:image.png)
        
    - 렌더링되지 않은 컴포넌트는 회색으로 표시되며 `Did not render` 라는 메시지가 표시된다. 이를 활용하면 개발자가 의도한 대로 메모이제이션이 작동하고 있는지, 혹은 특정 상태 변화에 따라 렌더링이 의도한 대로 제한적으로 발생하고 있는지 확인하는데 많은 도움을 얻을 수 있다.
    - 바는 **노란색에 가까울수록 렌더링에 오래 걸린 컴포넌트이며, 녹색에 가까울수록 빠르게 렌더링된 컴포넌트다. 회색으로 표시된 컴포넌트는 아예 렌더링되지 않은 컴포넌트다.**
    - `What caused this update?` 를 클릭해
- Ranked
    - 해당 커밋에서 렌더링하는 데 오랜 시간이 걸린 컴포넌트를 순서대로 나열한 그래프다.
    - Flamegraph 처럼 모든 컴포넌트를 보여주지 않고, 단순히 렌더링이 발생한 컴포넌트만 보여준다.
    - 렌더링이 발생한 컴포넌트에 대한 정보만 파악하고 싶다면 Ranked 메뉴를 활용하자.
- 타임라인
    - Timeline에서는 시간이 지남에 따라 컴포넌트에서 어떤 일이 일어났는지를 확인할 수 있다.
    - React 18 이상의 환경에서만 확인할 수 있다. 예를 들면 input에 글자를 입력하면서 state의 값이 업데이트되고, 이 값이 동기로 업데이트 됐는지, 또 언제 업데이트가 이뤄졌는지 등을 확인할 수 있다.
    - 시간의 흐름에 따라 리액트가 작동하는 내용을 추적하는데 유용하다. 시간 단위로 프로파일링기간 동안 무슨 일이 있었는지, 무엇이 렌더링됐고, 또 어느 시점에 렌더링됐는지, 리액트의 유휴 시간은 어느 정도였는지 등을 자세히 확인 가능하다.
- 첫번째, 두번째, 세번째, … n번째 렌더링 정보 확인
    - 다회차 렌더링 정보를 기록하여 확인할 수 있다.
    - 왼쪽, 오른쪽 화살표를 클릭해 좌우로 이동해가며 확인하면 된다.
    
    ```jsx
    What caused this update?
    	APP
    ```
    
    - 이 경우 해당 컴포넌트는 App, 즉 루트 컴포넌트로 인해 렌더링이 발생햇음을 알 수 있다.
    - 위에서 `APP` 클랙해 들어가면 `Hooks 1 changed` 라는 문구가 보인다. 이는 첫 번째 훅으로 인해 렌더링이 실행된다는 것을 의미한다. App의 첫 번째 훅을 확인하기 위해 컴포넌트 메뉴로 이동해서 App의 hooks를 보면, 1000 값이 들어가있는 1번 훅을 볼 수 있다.
        
        
        ![image.png](attachment:233a5599-f0aa-42aa-8d99-2aa50648b9e7:image.png)
        
        ![image.png](attachment:7ca3a78c-c552-4d71-8be7-820acb1adbe1:image.png)
        

## 정리

리액트 개발 도구를 활용하면 정적으로 생성된 컴포넌트 트리를 보는 것에서부터, 프로파일링을 통해 리액트 앱이 시간이 지남에 따라 어떤 식으로 작동하는지, 불필요한 리렌더링이 일아고 있는지 등을 확인할 수 있다.

위 실습에서는 간단한 코드를 가지고 실습했지만, 실제 리액트 앱은 대부분 매우 크고 복잡해 디버깅하기가 만만치 않다.

따라서 앱을 개발하면서 시간이 날 때마다 틈틈이 리액트 개발 도구로 컴포넌트 트리와 프로파일링을 실행해 원하는대로 렌더링 되고 있는지, 메모이제이션을 활용한 최적화는 잘 되고 잇는지 확인하자.

# 크롬 개발자 도구를 활용한 애플리케이션 분석

일반적인 브라우저 환경에서 발생할 수 있는 문제를 디버깅할 수 있는 도구를 **브라우저 개발자 도구**라고 한다.

## 크롬 개발자 도구란?

크롬 개발자 도구란 크롬에서 제공하는 개발자용 도구로, 웹페이지에서 일어나는 거의 모든 일을 확인할 수 있는 강력한 개발 도구다. 

크롬 개발자 도구에서 웹사이트를 제대로 디버깅하고 싶다면 **시크릿 모드** 또는 **프라이빗 모드라 불리는 개인정보 보호 모드**에서 페이지와 개발자 도구를 여는 것을 권장한다.

- 브라우저에 설치돼 있는 각종 확장 프로그램 때문이다. 확장 프로그램은 웹페이지 방문 시 확장 프로그램의 실행을 위해 전역 변수나 HTML 요소에 실제 웹 앱이 제공하지 않은 다른 정보를 추가할 수 있다.
- 이러한 정보는 개발자가 추가한 정보가 아닐뿐더러, 다른 사용자에게서는 볼 수 없는 정보로서 디버깅에 방해가 될 수 있다.

일부 설정에 따라 개인정보 보호모드에서도 실행될 수 있는 확장 프로그램이 있다면 꼭 꺼두거나 삭제하길 바란다.

## 요소(Element) 탭

현재 웹페이지를 구성하고 있는 HTML, CSS 등의 정보를 확인할 수 있다.

### 요소 화면

요소 화면에서는 HTML을 보고 코드를 수정해보는 것 뿐만 아니라, 배너와 같이 코드에 의해 클래스나 속성값이 동적으로 제어되는 DOM이 있다면 요소의 중단점을 사용해 디버깅할 수 있다. 

- HTML 코드에서 우클릭 → 중단 위치 → 하위 트리 수정 / 속성 수정 / 노드 삭제
- 만약 위에서 **`속성 수정`**을 선택한다면 해당 엘리먼트의 속성이 수정될 경우 중단이 걸리며 요소 변경을 일으킨 소스코드를 보여준다.

### 요소 정보

앨리먼트 탭의 오른쪽에서는 해당 요소와 관련된 정보를 얻을 수 있다. 요소 정보에서 확인할 수 있는 주요 내용은 다음과 같다.

- 스타일 : 요소와 관련된 스타일 정보를 나타낸다. 어떤 클래스, 태그명, 아이디 등으로 매핑되어 설정된 스타일인지 확인할 수 있고, 또한 스타일이 선언돼 있는 파일도 확인할 수 있다. 요소와 마찬가지로 이 스타일 정보의 내용도 수정해 페이지에 어떻게 반영되는지 미리 확인해 볼 수 있다.
- 계산됨 : 해당 요소의 크기, 패딩, 보더, 마진과 각종 CSS 적용 결괏값을 알 수 있는 탭이다. 스타일 탭은 어떤 스타일이 어디서 왔는지를 나타내면, 계산됨에서는 그렇게 적용된 스타일이 결과적으로 어떤 결과물로 나타나는지 확인할 수 있다.
- 레이아웃 : CSS 그리드나 레이아웃과 관련된 정보를 확인할 수 있다.
- 이벤트 리스너 : 현재 요소에 부착된 각종 이벤트 리스너를 확인할 수 있다.
- DOM 중단점 : 앞서 설명한 중단점이 있는지 알려주는 탭이다.
- 속성 : 해당 요소가 가지고 있는 모든 속성값을 나타낸다.
    - 기본적으로 JS에서 해당 DOM으로 `.attributes`를 실행했을 때 나오는 결과와 비슷하지만 `.attributes`는 직접 할당된 값만 나오는 반면 속성 탭에서는 모든 값이 나온다.
- 접근성 : 접근성이란 웹 이용에 어려움을 겪는 장애인, 노약자를 위한 스크린리더기 등이 활용하는 값을 말한다. 접근성 탭에서는 이러한 접근성 정보를 확인할 수 있다.

## 소스 탭

소스 탭에서는 웹 앱을 불러오기 위해 실행하거나 참조된 모든 파일을 확인할 수 있다. JS 파일부터, CSS, HTML, 폰트까지 다양한 파일 정보를 확인할 수 있다.

- 프로덕션 모드의 경우 파일이 모두 압축돼 있기 때문에 디버깅하기가 매우 불편하지만, 개발 모드에서는 유용하게 사용할 수 있다.

앞서 요소 탭에서 DOM 중단점을 만들어 DOM이 변경되는 과정을 디버깅해 볼 수 있었던 것처럼, 여기서도 소스 중단점을 생성해 JS 실행을 중단시키고 디버깅을 수행할 수 있다. 

- 이는 debugger를 선언하는 것과 동일한 역할을 하지만 코드를 오염시키지 않으므로 더 유용하다.
    
    ![image.png](attachment:39330d72-c8a8-4963-a5c5-04c5ca8b5eaf:image.png)
    
    - 감시 : 감시하고 싶은 변수를 선언하고, 해당 변수의 정보를 확인할 수 있다. 감시로 확인할 수 없는 값은 <not available>로 표시되는 것을 볼 수 있다.
    - 중단점 : 현재 웹사이트에서 추가한 중단점을 확인할 수 있다. **현재 열려 있는 파일뿐만 아니라 웹페이지 전체에 걸쳐 소스탭에서 추가한 모든 중단점**을 확인할 수 있다.
    - 범위 : 범위는 이름 그대로 **현재 중단점에서의 스코프를 의미한다. 로컬은 현재 로컬 스코프를 의미하며, 이 스코프에서 접근할 수 있는 값**을 확인할 수 있다. 이 밖에도 클로저, 전역 스코프 등을 확인할 수 있다.
    - 호출 스택 : 호출 스택에서는 현재 중단점의 콜스택을 확인할 수 있다. 이 메뉴를 활용하면 JS 코드가 실행되며 생성되는 실행 콘텍스트가 어떻게 저장되어 현재 어떤 모습을 하고 있는지 직접 볼 수 있다.
    - 전역 리스너 : 현재 전역 스코프에 추가된 리스너 목록을 확인할 수 있다.
    - XHR/가져오기, DOM, 이벤트 리스너, CSP 위반 중단점 : 소스의 중단점 이외에 다양한 중단점을 확인할 수 있다.
- 이처럼 변수의 값을 미리 보여주는 기능, 감시에 변수를 추가해 실제 변숫값을 확인하는 기능을 사용한다면 굳이 번거롭게 변수마다 console.log로 디버깅하지 않아도 훨씬 빠르게 필요한 정보를 확인할 수 있다. 또한 JS 스크립트 파일에서는 확인 불가능한 스코프, 호출 스택 등 현재 JS가 실행되고 있는 구조도 확인할 수 있어 유용하다.
    - 소스 탭은 웹사이트 디버깅 시 요소 탭과 더불어 가장 자주 사용되는 도구이므로 적극 활용해보자.

## 네트워크 탭

네트워크 탭에는 해당 웹페이지를 접속하는 순간부터 발생하는 모든 네트워크 관련 작동이 기록된다. 

- HTTP 요청부터 웹 소켓에 이르기까지, 웹페이지가 외부 데이터와 통신하는 정보를 확인하고 싶다면 네트워크 탭을 참조해라.

![image.png](attachment:f3022d52-e3b7-4859-9741-d164f56106fd:image.png)

- 상단에는 네트워크 탭과 관련된 다양한 메뉴를 확인할 수 있다. `전체`, `Fetch/XHR` , `JS` 등의 탭으로 보고 싶은 네트워크 요청 종류를 필터링할 수 있으며, 기타 다른 체크박스를 선택해 보고 싶은 네트워크 종류를 제한할 수 있다.
- 왼쪽의 리스트는 실제 해당 페이지를 불러오는 과정에서 발생한 네트워크 요청이다. 페이지가 로딩되는 과정을 대략적으로 확인해 볼 수도 있다.
- 동일한 주소의 요청이 두 번 실행되는 경우는 대부분 잘못된 useEffect의 사용으로 발생하는 문제다. → 네트워크 탭을 자세히 들여다보면 이처럼 리액트 코드에 문제가 있는지도 확인할 수 있다.
- 우측 상단 (두번째) 톱니바퀴를 클릭해서 **스크린샷**을 체크하면 스크린샷 캡쳐 기능을 활용할 수 있다. 웹페이지가 어덯게 로딩되고 있는지 확인할 수 있다.

네트워크 탭을 통해 집중적으로 봐야 하는 점은 다음과 같다.

- 불필요한 요청 또는 중복되는 요청이 없는지
- 웹페이지 구성에 필요한 리소스 크기가 너무 크지 않은지
- 리소스를 불러오는 속도는 적절한지 또는 너무 속도가 오래 걸리는 리소스는 없는지
- 리소스가 올바른 우선순위로 다운로드되어 페이지를 자연스럽게 만들어가는지

## 메모리 탭

메모리 탭에서는 현재 웹페이지가 차지하고 있는 메모리 관련 정보를 확인할 수 있다. 

크롬 개발자 도구에서 제공하는 도구 중 가장 난이도가 높고 까다롭다. 하지만 앱에서 발생하는 메모리 누수, 속도 저하, 혹은 웹페이지 프리징 현상을 확인할 수 있는 유용한 도구다.

프로파일링 유형은 크게 세 가지다.

- 힙 스냅샷 : 스냅샷이라는 이름에 걸맞게 현재 메모리 상황을 사진 찍듯이 촬영할 수 있다. 현재 시점의 메모리 상황을 알고 싶다면 힙 스냅샷을 활용하면 된다.
- 타임라인의 할당 계측 : 현재 시점의 메모리 상황이 아닌, 시간의 흐름에 따라 메모리의 변화를 살펴보고 싶다면 `타임 라인의 할당 계측`을 사용하면 된다. 주로 로딩이 되는 과정의 메모리 변화 또는 페이지에서 어떠한 상호작용을 했을 때의 메모리의 변화 과정을 알고 싶을 때 사용한다.
- 할당 샘플링 : 메모리 공간을 차지하고 있는 JS 함수를 볼 수 있다.

### JS 인스턴스 VM 선택

하단에 위치한 `자바스크립트 VM 인스턴스 선택` 항목을 살펴보면 현재 실행 중인 JS VM 인스턴스를 확인할 수 있다. 

- 여기서 개발자가 디버깅하고 싶은 JS VM 환경을 선택하면 된다.
- 환경별 힙 크기를 볼 수 있다. 실제 해당 페이지가 JS 힙을 얼마나 점유하고 있는지 나타낸다. 이 크기는 JS 실행에 따라 실시간으로 바뀐다. **이 크기 만큼 사용자의 브라우저에 부담을 주기 때문에 불필요하게 크기가 늘어나지 않는지** 눈여겨볼 필요가 있다.

![image.png](attachment:29771085-08ed-4b69-b1c2-a37ad05d3190:image.png)

### 힙 스냅샷

현재 페이지의 메모리 상태를 확인해 볼 수 있는 메모리 프로파일 도구다.

촬영하는 시점을 기준으로 마치 사진으로 촬영하듯 메모리 현황을 보여준다.

예를 들어 아래와 같이 BUG 버튼을 클릭했을 때 외부 배열에 천만 개의 랜덤한 값을 push 하는 말도 안되는 코드를 개발했을 때, 메모리 탭의 힙 스냅샷을 활용하면 BUG 버튼을 누르기 전후의 힙 스냅샷을 비교해, 어떤 변수가 메모리를 크게 잡아먹고 있는 지를 확인할 수 있다. 

- 두 스냅샷 간 사이에 일어났던 유저 인터랙션, 즉 버튼 클릭으로 인해 메모리 사용량 차이가 발생했다는 것을 명확히 확인할 수 있다.

```jsx
const DUMMY_LIST = [];

export default function App() {
	function handleClick() {
		Array.from({ length : 10_000_000 }).forEach(function addDummy(_, idx) {
			DUMMY_LIST.push(Math.random() * idx)
		});
		alert('complete');
		
		return <button onClick={handleClick}>BUG</button>
	}
}
```

힙 스냅샷을 통해 메모리 누수 정보를 확인하기 위해서는 메모리 누수가 발생하는 것으로 예상되거나 혹은 위험이 존재할 것 같은 스크립트 전후로 내용을 촬영해 비교하는 것이 좋다.

그리고 원인을 더욱 정확하게 파악하기 위해 변수와 함수에 꼭 적절한 이름을 부여하자.

### 타임라인 할당 계측

타임라인 할당 계측은 시간의 흐름에 따라 메모리 변화를 확인할 수 있는 기능이다. 시간의 흐름에 따라 메모리의 변화를 모두 기록하기 때문에 상대적으로 많은 부담이 발생한다.

- 타임라인 할당 계측의 장점은 기간을 좁혀서 확인해 볼 수 있다는 것이다. 상단 그래프에서 검색을 원하는 범위를 좁히면 **해당 기간에 메모리에 할당된 내용만 골라서** 볼 수 있다.
    
    ![image.png](attachment:9c31df89-0d28-4af6-a07b-547fffd8302e:image.png)
    
- 특정 변수를 우클릭해 `전역 변수로 저장` 을 누르면 해당 변수가 무슨 값을 가지고 있는 객체인지 확인할 수도 있다. 전역 변수로 저장하면 하단 콘솔에서 해당 변수를 확인 가능하다.

타임라인 할당 계측을 활용하면 이처럼 시간의 흐름에 따른 메모리 변화를 비롯해 메모리 변화를 일으킨 변수가 무엇인지, 그리고 해당 변수가 어느 정도 크기를 차지하고 있는지 등을 확인할 수 있다.

시간의 흐름에 따른 메모리 점유율을 자세히 알고 싶다면 `타임라인 할당 계측`을 활용하자.

### 할당 샘플링

할당 샘플링은 시간의 흐름에 따라 발생하는 메모리 점유를 확인할 수 있다는 점에서 타임라인 할당 계측과 비슷하지만, JS 실행 스택별로 분석할 수 있고, 이 분석을 함수 단위로 한다는 차이가 있다.

힙 스냅샷 파트에서 사용했던 예제를 다시한번 활용해, 할당 샘플링으로 관찰해보면 두 가지 사항을 관찰할 수 있다.

1. 최초에는 6.5MB 정도만 차지했던 힙이, 버튼을 클릭한 후에는 395MB 까지 치솟은 것을 확인 가능하다. 
2. 할당 샘플링을 무거운 순으로 정렬하면 가장 많은 바이트를 차지한 함수의 작업이 맨 위로 올라온다. 여기서 `addDummy` 함수가 문제임을 알 수 있다.
    - 마우스 오른쪽 버튼을 클릭해 `소스 패널에 표시`를 클릭하여 해당 함수가 어떻게 정의됐는지도 확인 가능하다.

할당 샘플링은 타임라인 할당 계측과 유사하지만 프로파일링할 때 브라우저에 주는 부담을 최소화할 수 있어 장시간에 걸쳐 디버깅을 수행해야 할 때 유리하다.

만약 메모리 누수가 짐작되지만 정확히 어디에서 발생하는지 확인하기 어려워 힙 스냅샷 사용이 어려운 경우, 할당 샘플링을 사용하면 좋다.