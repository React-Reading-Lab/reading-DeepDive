## 04 서버 사이드 렌더링

사용자의 기기의 성능이 좋아짐에도 불구하고 과거와 현재의 대기 시간의 차이는 거의 존재하지 않는다.

### 서버 사이드 렌더링 장점

1. 최초 페이지 진입이 비교적 빠르다.

2. 검색 엔진과 SNS 공유 등 메타데이터 제공이 쉽다.
   검색 엔진 최적화에 유용하다.

[ 검색 엔진이 사이트에 필요한 정보를 가져가는 과정]

- 검색 엔진 로봇이 페이지에 진입한다.
- 페이지가 HTML 정보를 제공해 로봇이 이 HTML을 다운로드한다. 단 다운로드만 하고 JS파일을 실행하지 않는다.
- 다운로드한 HTML 페이지 내부의 오픈 그래프나 메타 태그 정보를 기반으로 페이지의 검색 정보를 가져오고 이를 바탕으로 검색 엔진이 저장한다.

3. 누적 레이아웃 이동이 적다.

누적 레이아웃 이동이란 페이지를 보여준 이후에 뒤늦게 어떤 HTML 정보가 추가되거나 삭제되어 마치 화면이 덜컥거리는 것과 같은 부정적인 사용자 경험을 말한다.

SPA의 경우 API의 요청에 의존하여 각 렌더링되는 요소의 속도가 다를 수 있어 누적 레이아웃 이동의 빈도가 높을 수 있다.

하지만 서버 사이드 렌더링을 사용한다 하더라도 이러한 문제에서 자유롭지는 못하다.

useEffect의 경우 컴포넌트가 마운트된 이후에 실행되기 때문에 SSR이든 CSR이든 문제가 발생할 여지가 존재한다.

그러나 이는 리액트 18에서 등장한 `스트림`으로 인해 해결될 수 있다.

4. 사용자의 디바이스 성능에 비교적 자유롭다.

서버에서 페이지를 만들어 넘겨주기 때문에 사용자의 디바이스 성능에 CSR에 비해 덜 의존적이다.

5. 보안에 더 안전하다.

민감한 작업을 서버에서 수행한 뒤 브라우저에 제공하여 CSR보다는 좀 더 보안 위협으로부터 안전할 수 있다.

### 단점

1. 소스코드를 작성할 때 항상 서버를 고려해야 한다.

소스코드 전반에 걸쳐 서버 환경에 대한 고려가 필요하다. 그 중 가장 큰 문제는 바로 브라우저의 전역 객체인 `window`같이 브라우저에만 존재하는 전역 객체 등이다.

2. 적절한 서버가 구축되어 있어야 한다.

3. 서비스 지연에 따른 문제

서버 단에서 지연이 발생하면 클라이언트에서는 유저에게 어떠한 정보도 제공해줄 수 없다. 이러한 점은 사용자 경험을 해칠 수 있다.

## 4.1.3 SPA와 SSR을 모두 알아야 하는 이유

### 서버 사이드 렌더링 역시 만능이 아니다.

어떤 것을 우선순위로 둘 지 결정하고 이에 따라 영리하게 두가지 선택지 중 하나를 선택하여 사용하는 것이 효율적이다.

### 싱글 페이지 어플리케이션과 서버 사이드 렌더링 어플리케이션

고점은 싱글 페이지 어플리케이션 -> GMAIL이 좋은 예시

저점 방어는 서버 사이드 렌더링 어플리케이션 -> 평균적인 레이턴시를 기대할 수 있음

### 현대의 서버 사이드 렌더링

요즘은 초기 페이지의 HTML과 자바스크립트를 서버에서 다운받고 이후의 라우팅은 모두 자바스크립트 파일을 통해서 하는 방식을 많이 사용한다.

이는 초기 로드 속도 개선과 라우팅 시 사용자 경험이 뛰어나다는 장점이 존재한다.

# 4.2 서버 사이드 렌더링을 위한 리액트 API 살펴보기

## 4.2.1 renderToString

컴포넌트를 HTML 문자열로 변환해주는 함수이다. 단순 문자열로 변환되기 때문에 useEffect나 이벤트 핸들러가 존재하지 않고 후에 `hydrate`함수를 사용하여 자바스크립트를 이식해주어야 한다.

이때 root 엘리먼트에 `data-reactroot` 속성이 붙는다. 이를 보고 후에 `hydrate` 함수가 루트를 식별할 수 있다.

## 4.2.2 renderToStaticMarkup

`renderToString`과 비슷한 일을 하지만 `renderToStaticMarkup`은 순수한 HTML 문자열을 만든다. 이는 `hydrate`를 수행하더라도 자바스크립트를 이식해줄 수 없다.

root 엘리먼트에 `data-reactroot` 속성이 존재하지 않아서 `hydrate`가 루트를 식별할 수 없다.

## 4.2.3 renderToNodeStream

`renderToNodeStream`과 `renderToString`의 결과물은 완전히 동일하지만 두가지 차이점이 존재한다.

1. `renderToNodeStream`은 브라우저에서 사용하는 것이 불가능하다. 완전히 `Node.js` 환경에 의존하기 때문.

2. 결과물의 타입

`renderToNodeStream`의 결과물은 NodeJs의 `ReadableStream`이다. `ReadableStream`은 _utf-8로 인코딩된 바이트 스트림_

[ `renderToNodeStream`는 왜 필요한 것인가? ]

매우 큰 작업 단위를 청크단위로 쪼개서 순차적으로 처리할 때 매우 좋다. (Stream 형식이기 때문에 가능하다.)

대부분 널리 알려진 리액트 서버 사이드 렌더링 프레임워크는 모두 `renderToString` 대신 `renderToNodeStream`을 채택하고 있다.

## 4.2.4 renderToStaticNodeStream

`hydrate`할 필요 없는 순수 HTML 결과물이 필요할 떄 사용하는 메서드

## 4.2.5 hydrate

앞서 본 메서드의 결과물로 생성된 HTML 컨텐르에 자바스크립트 핸들러나 이벤트를 붙이는 역할을 한다.
