# 13 웹페이지의 성능을 측정하는 다양한 방법

## 13.1 애플리케이션에서 확인하기

### 13.1.1 create-react-app

CRA를 통해 프로젝트를 시작한 경우 `reportWebVitals`라는 함수가 자동으로 생성된다. 해당 함수는 웹에서 성능을 측정하기 위한 함수로 CLS, FID, FCP, TTFB를 측정하는 용도이다.
이러한 지표를 측정할 수 있도록 도와주는 것이 `web-vitals`라는 라이브러리이다. 이러한 자바스크립트 수준의 라이브러리가 브라우저의 웹 페이지 성능을 측정할 수 있는 이유는 `PerformanceObserver`라는 API를 사용하기 때문이다. 반대로 이야기 하자면 `PerformanceObserver`를 제공하지 않는 브라우저에서는 `web-vitals`를 활용하여 성능을 측정하기 어렵다.

### 13.1.2 create-next-app

Nextjs에서는 성능을 측정할 수 있는 함수 `NextWebVitalsMetric`을 제공한다.

\_app 페이지 내에 아래의 코드를 추가해보자.

```javascript
export declare type NextWebVitalsMetric = {
  id: string;
  startTime: number
  ...
}

export function reportWebVitals(metric: NextWebVitalsMetric) {
  console.log(metric)
}

function MyApp({Component, pageProps}: AppProps ) {
  return <Component {...pageProps} />
}
```

예약어로 지정된 `reportWebVitals`를 생성하면 TTFB, FID. LCP 등에 대한 정보를 얻을 수 있다.

기본적인 핵심 지표 외에도 Next에 특화된 사용자 지표도 제공한다

- Next.js-hydration: 페이지가 서버 사이드에서 렌더링되어 하이드레이션하는 데 걸린 시간
- Next.js-route-change-to-render: 페이지가 경로를 변경한 후 페이지를 렌더링 시작하는 데 걸리는 시간
- Next.js-render: 경로 변경이 완료된 후 페이지를 렌더링하는 데 걸리는 시간

## 13.2 구글 라이트하우스

구글 라이트하우스를 이용하면 별도의 코드 수정 없이 손쉽게 성능 지표를 수집할 수 있다.

구글 라이트하우스는 구글에서 제공하는 웹 페이지 성능 측정 도구로 오픈소스로 운영되고 있다.

- 크롬 개발자 도구에는 라이트하우스가 기본적으로 내장되어 있다.

- CLI: lighthouse라는 npm 라이브러리를 이용하면 cli 명령어로 지표를 수집할 수 있다.

### 13.2.1 구글 라이트하우스 - 탐색 모드

페이지에 접속했을 때부터 페이지 로딩이 완료될 떄까지의 성능을 측정하는 모드이다.

#### 성능 탭

핵심 웹 지표인 FCP, LCP, CLS와 추가로

- Time to Interactive (사용자가 완전히 상호작용할 수 있을 때까지 걸린 시간)

  웹 페이지가 최대한 빠르게 상호작용이 되도록 준비하려면 메인 스레드가 하는 자바스크립트 작업을 최소화하고 전체적인 자바스크립트 실행 속도 또한 높일 필요가 있다.

- Speed Index (페이지가 로드되는 동안 컨텐츠가 얼마나 빨리 시각적으로 표시되는지를 계산한다.)

  브라우저에서 로드되는 페이지를 실시간으로 캡터하고 캡처된 이미지를 분석하여 speed index를 계산한다.

- Total Blocking Time (메인 스레드에서 특정 시간 이상 실행되는 작업, 즉 긴 작업이 수핼될 때마다 메인 스레드가 차단된 것으로 간주한다.)

  메인 스레드가 차단되었다고 표현하는 이유는 브라우저가 길게 수행되는 작업으로 인해 다른 작업을 수행할 수 없는 상태이기 때문이다.
  총 차단 시간은 모든 긴 작업을 대상으로 하는 것은 아니고 FCP부터 상호작용까지 걸리는 시간 사이의 작업만 대상으로 한다.

성능에서는 해당 6가지 지표에 대한 점수를 계산하여 보여준다.

#### 접근성 탭

웹 접근성을 의미하며 장애인 및 고령자 등 신체적으로 불편한 사람들이 일반적인 사용자와 동등하게 웹페이지를 이용할 수 있는 것을 보장하는 것을 의미한다.

다양한 사용자를 배려하기 위해 HTML, CSS 등에 적절한 대안을 삽입하는 것을 접근성이라 하며 이 영역에서 평가하는 것은 얼마나 적절하게 접근성을 제공하는지 여부이다.

#### 권장사항 탭

권장사항 영역에서는 웹사이트를 개발할 때 고려해야 할 요소들을 얼마나 지키고 있는지 확인할 수 있다.

여기서 말하는 권장사항들은 보안, 표준모드, 최신 라이브러리, 소스 맵 등 다양한 요소들이 포함되어 있다.

- CSP가 CSS 공격에 효과적인지 확인 : XSS란 제3자가 삽입한 스크립트를 통해 공격하는 기법을 의미한다. CSP란 웹 사이트에서 호출할 수 있는 컨첸츠를 제한하는 정책을 말한다.

- 감지된 Javascript 라이브러리 : 페이지에서 감지되는 자바스크립트 라이브러리를 말한다.

- HTTPS 사용

- 페이지 로드 시 위치정보 권한 요청 방지하기 : 사용자의 동의 없이 페이지 로드 시 사용자의 물리적 위치를 알 수 있는 메서드를 실행하는지 확인한다. 해당 메서드가 실행된다고 바로 위치 정보를 가져오는 것은 아니지만 사용자의 어떠한 액션 이후에 실행되는 것이 바람직하다.

- 알려진 보안 취약점이 있는 프런트엔드 자바스크립트 라이브러리를 사용하지 않음 : 보안 취약점이 존재하는 라이브러리를 사용하는지 확인한다.

- 사용자가 비밀번호 입력란에 붙여넣을 수 있도록 허용 : 반드시 비밀번호 입력란은 붙여넣기가 가능해야 한다.

- 이미지를 올바른 가로세로 비율로 표시 : 이미지의 실제 크기와 표시되는 크기 사이의 비율이 일치하는지 확인한다.

- 이미지가 적절한 해상도로 제공됨 : 이미지를 선명하게 보일 수 있도록 크기에 맞는 해상도의 이미지를 제공하는지 확인

- 페이지에 HTML Doctype 있음 : Doctype이 선언되지 않은 경우 호환모드로 렌더링되는 불필요한 작업이 발생

- 문자 집합을 제대로 정의함 : 서버가 HTML 파일을 전송할 때 문자가 어떻게 인코딩돼 있는지 지정하지 않으면 브라우저는 각 바이트가 나타내는 문자를 알 수 없게된다. 따라서 적절한 charset을 지정해줘야 한다. 대부분의 웹페이지의 <head> 태그 내부에 <meta charset='utf-8'>을 삽입해 UTF-8로 인코딩됐다고 명시한다.

- 지원 중단 API 사용하지 않기 : 더 이상 지원하지 않는 API는 잠재적 보안 위험성이 존재할 수 있으므로 사용하지 않는 것이 권장된다.

- 콘솔에 로그된 브라우저 오류 없음 : 콘솔에 에러가 기록되는 것은 사용자에게 영향을 미치지 않을 수도 있지만 분명 웹사이트에 문제가 있다는 사실에는 변함이 없다. 따라서 콘솔레 에러가 기록되지 않게 해야 한다.

- Chrome Devtools의 Issue가 없음

- 페이지에 유효한 소스맵이 존재함 : 소스 맵은 압축되어서 읽기 어려우진 소스코드를 원본 소스코드로 변환할 수 있도록 도와주는 파일로, 이 소스 맵이 있으면 개발자가 디버깅하는 데 큰 도움이 된다. 따라서 디버깅 해야한다면 소스맵이 있는 것이 도움이 되지만 아니라면 별도로 제공하지 않아도 된다.

- font-display: optional을 사용하는 폰트가 미리 로드됨

#### 검색 엔진 최적화

검색엔진이 쉽게 웹페이지 정보를 가져가서 공개할 수 있도록 최적화돼 있는지를 확인하는 것을 의미한다. 단순히 문서를 크롤링하기 쉽게 만들었나부터, robots.txt가 유효한지, 이미지와 리읔에 설명 문자가 존재하는지. <meta>나 <title> 등으로 페이지의 정보를 빠르게 확인할 수 있는지 등을 확인한다.

### 13.2.2 구글 라이트하우스 - 기간 모드

기간 모드는 시리제 웹페이지를 탐색하는 동안 지표를 측정하는 것이다.

사용자가 빈번하게 사용할 기능들을 기간 모드로 측정하면 성능 최적화에 도움을 받을 수 있다.

앞에서 볼 수 없었던 내용 두가지가 있는데 이것은 바로 흔적과 트리맵이다.

#### 흔적

흔적은 `View Trace`를 번역한 말로 웹 성능을 추적한 기간을 성능 탭에서 보여준다.

#### 트리맵

트리맵은 페이지를 불러올 때 함께 로딩한 모든 리소스를 함께 모아서 볼 수 있는 곳이다. 웹페이지의 전체 자바스크립트 리소스 중 어떠한 파일이 전체 데이터 로딩 중 어느 정도를 차지 했는지 비율로 확인할 수 있으며 실제 불러온 데이터의 크기를 확인할 수도 있다.

한가지 더 확인할 수 있는 것은 로드한 리소스 중 사용하지 않는 바이트의 크기를 확인할 수 있는 것인데 이는 불러왔지만 사용되지 않는 리소스를 의미한다.

### 13.2.3 구글 라이트하우스 - 스냅샷

스냅샷 모드는 탐색 모드와 유사하지만 현재 페이지 상태를 기준으로 분석하다는 점이 다르다.

## 13.3 WebPageTest

WebPageTest 사이트는 유료 기능도 있는 만큼 보다 더 심도있는 분석이 가능하다.
WebPageTest에서 제공하는 분석 도구는 크게 다섯 가지가 존재한다.

- Site Performane: 웹사이트의 성능 분석을 위한 도구
- Core Web Vitals: 핵심 웹 지표를 확인하는 도구
- Lighthouse: 구글의 라이트하우스 도구
- Visual Comparison: 2개 이상의 사이트를 동시에 실행해 시간의 흐름에 따른 로딩 과정을 비교하는 도구
- Traceroute: 네트워크 경로를 확인하는 도구

### 13.3.1 Performance Summary

사이트의 주소를 입력하고 Start Test를 누르면 웹사이트 성능 검사가 시작된다.

성능 테스트는 총 3번 이루어지므로 3개의 서로 다른 결과를 확인할 수 있다.

측정 결과 페이지는 크게 세가지 영역으로 나뉘어져 있다.

- Opportunities & Experimentals

  - Is it Quick: 웹사이트가 충분히 빠른지 평가한다.

  - Is it Usable: 웹사이트의 사용성과 시각적인 요소를 확인한다. CLS를 최소화하고 있는지 상호작용을 빠르게 할 수 있는지 접근성 이슈가 있는지를 검사한다.

  - Is it Reslient: 보안 취약성을 검사한다. 렌더링을 블로킹하는 제3의 라이브러리가 존재하는지 실질적인 위협이 되는 보안 위험요소가 있는지를 나타낸다.

- Observed Metrics: 최초 바이트까지의 시간, 렌더링 시작에 소요되는 시간 등 측정할 수 있는 다양한 시간 지표를 나타낸다.

  - 주황 실선: 웹사이트의 모습이 변경된 경우
  - 주황 점선: 웹사이트 모습 변경과 레이아웃 이동 발생
  - 빨강 실선: 최대 컨텐츠풀 페인트
  - 빨강 점선: 최대 컨텐츠풀 페인트와 동시에 레이아웃 이동이 발생

- Individual Runs: 각 실행 별로 어떠한 결과를 보여주는지 확인할 수 있다.

### 13.3.2 Opportunities & Experimentals

- TTFB를 점검.

- 렌더링 블로킹하는 자바스크립트 요소가 있는지 확인

- 렌더링 블로킹하는 CSS 요소가 있는지 확인

- FCP가 2.5초 이내인지 확인

- 주요 영역 내 lazy loading이 존재하는지 확인한다.

- 주요 영역 외 lazy loading이 되는지 확인한다.

- 문자의 노출을 지연시키는 커스텀 폰트가 있는지 확인한다. 만약 font-display: block으로 폰트를 불러오면 사용자 경험을 해칠 수 있다.

- 제3자 호스트에서 폰트를 불러오는지 확인한다.이제 폰트는 캐싱되지 않으므로 제3자 호스트에서 폰트를 불러오는 것은 크게 이점이 없다. 웹사이트와 동일한 곳에서 폰트를 호스팅하거나 rel=preload로 브라우저에 최우선 리소스임을 알려주거나 rel=preconnect로 미리 해당 오리진에 연결할 수 있게끔 하는 것이 좋다.

- 실제로 사용하지 않는 리소스를 rel=preload로 불러오지 않는지 확인한다.

- HTTP 리다이렉트되는 리소스가 없어야 한다.

- 최초로 다운로드 받은 HTML과 최종 결과 HTML 사이에 크기 차이가 적어야 한다. 둘의 차이가 클수록 자바스크립트가 하는 일이 많기 때문에 이는 초기 로드 속도 저하를 유발한다.

- Is it Usable

  - 이미지 비율 부재로 인한 레이아웃 이동 가능성 여부를 확인한다.
  - 어떤 이유에서건 메인 스레드가 장시간 막혀 있어서는 안 된다.
  - meta: viewport가 적절하게 삽입돼 있어야 한다. 가장 많이 정의하는 속성은 다음과 같다.
    <meta name='viewport' content='width=device-width, initial-scale=1'>
  - 접근성 이슈가 있는지 확인한다.

- Is it Resilient

  - 위의 내용 참고

### 13.3.3 Filmstrip

시간의 흐름에 따라 웹사이트가 어떻게 그려졌는지 또 어떤 리소스가 불러와졌는지 볼 수 있는 메뉴다.

### 13.3.4 Details

Filmstrip에서 보여준 내용을 자세하게 보여주는 영역이다.

### 13.3.5 Web Vitals

LCP, CLS, TBT에 대한 자세한 내용을 확인할 수 있다.

### 13.3.6 Optimizations

리소스들이 얼마나 최적화돼 있는지 나타낸다. 여기서 확인할 수 있는 내용은 다음과 같다.

- Keep-Alive 설정으로 서버와의 연결을 계속 유지하고 있는가
- Gzip으로 리소스를 압축하고 있는가
- 이미지를 적절하게 압축했는지
- Progressive JPEG으로 JPEG 이미지를 렌더링하고 있는지
- 리소스 캐시 정책이 올바르게 수립돼 있는가
- 리스소가 CDN을 거치고 있는가

### 13.3.7 Content

웹 사이트에서 제공하는 컨텐츠, 에셋을 종류별로 묶어 통계를 보여준다. 에셋 종류별 크기와 로딩 과정을 확인할 수 있으며 시간의 흐름에 따라 렌더링을 거치면서 또 어떻게 에셋을 불러오는지도 확인할 수 있다.

### 13.3.8 Domains

Content 영역에서 확인한 에셋들이 어느 도메인에서 왔는지 도메인 별로 묶어서 확인할 수 있다.

### 13.3.9 Console log

사용자가 웹페이지에 접속했을 때 콘솔에 어떤 것이 기록되는지 확인할 수 있다. 가급적이면 console.log를 사용하여 로그를 찍는 일은 없어야 한다.

### 13.3.10 Detected Technologies

웹사이트를 개발하는 데 사용된 기술을 확인할 수 있는 메뉴이다.

### 13.3.11 Main-thread Processing

해당 메뉴의 하위 항목인 Processing Breakdown에서 메인 스레드가 어떤 작업을 처리했는지 확인할 수 있다. 여기서는 리소스를 기다리는 Idle time은 집계에 포함하지 않는다.
메인 스레디의 작업을 크게 다섯가지로 분류해 알려준다. (스크립트 실행, 레이아웃, 리소스 로딩, 페인팅, 기타)

Timing Breakdown은 Idle time을 포함한 메인 스레드 작업 시간을 알 수 있다.

### 13.3.13 기타

이 외의 메뉴는 WebPageTest의 외부에서 제공하는 서비스이다.

## 13.4 크롬 개발자 도구

### 13.4.1 성능 통계

라이트하우스가 비슷하게 페이지 로드 시점부터 페이지의 성능을 측정할 수 있고 또는 특정 시점의 성능을 측정해볼 수도 있다.

Throttling 기능은 고의로 네트워크 또는 CPU 성능을 떨어뜨려 저사양의 디바이스에서 어떻게 동작하는지 측정해볼 수 있다.

#### Insights

성능을 측정하는 기간 동안 발생한 이벤트 중 눈여겨봐야 할 내용을 시간의 흐름에 따라 모아서 보여준다.

- 핵심 웹 지표가 등장한다.

- Performance Measure: User Timing API로 측정한 지표들을 확인할 수 있다.

- Long Task: 메인 스레드에서 실행되는 데 오랜 시간으로 분류된 긴 작업을 의미한다. 클릭하면 어떤 작업인지 상세한 정보를 볼 수 있다.

- Render blocking CSS: 렌더링을 막는 CSS

- Forced Style recalculation: 이미 스타일이 계산된 이후에 어떤한 이유로 스타일이 다시금 계산되는 작업이 강제로 발생했음을 의미한다.

#### 메인 메뉴

...

### 13.4.2 성능

Performance Insights 탭이 등장하기 이전부터 있던 탭으로 성능 분석에 사용하기 위해 만들어진 탭이다. 더 자세한 정보를 담고있다.

#### 메뉴

성능 탭에서 사용할 수 있는 메뉴를 확인할 수 있다.

#### 요약

요약 탭에서는 측정 기간의 CPU, 네트워크 요청, 스크린숏, 메모리 점유율 등을 요약해서 볼 수 있다. 드래그를 통해 특정 시점에 대한 정보를 볼 수 있다.

#### 네트워크

성능 측정 기간 동안에 발생한 모든 네트워크 요청을 확인할 수 있다.

- 파란색: HTML
- 보라색: CSS
- 노란색: JS
- 초록색: 이미지
- 회색: 기타
- 폰트
- JSON 등

그리고 위에 있는 요청이 우선순위가 높은 요청이다.

그래프 읽는 방법

- 왼쫀 선은 연결 시작되기 위한 기간을 나타낸다.
- 대표 색상의 막대 그래프 중 색이 더 연한 왼쪽은 요청을 보내고 최초 바이트가 오기까지의 대기 시간을 의미한다.
- 대표 색상의 막대 그래프 중 색이 진한 오른쪽은 컨텐츠를 다운로드하는 데 걸리는 시간을 의미한다.
- 그리고 마지막에 거의 안 보이는 오른쪽 선은 메인 스레드이 응답을 기다리는 시간인데 이는 네트워크의 소요 시간에 포함하지 않는다.

진한 색 영역이 크다면 내용이 큰 파일이라는 뜻이다.

#### web vitals

#### 소요 시간과 기본

성능 탭의 핵심. 시간의 흐름에 따라 메인 스레드의 작업이 어떻게 이루어졌는지 또 자바스크립트 힙 영역은 어떻게 변화하는지 확인할 수 있다.

기본 탭에서 현재 메인 스레드의 작업을 볼 수 있는데 메인 스레드가 수행하는 다양한 작업을 볼 수 있다.

함수 호출을 예로 들면,

기본적으로 함수 호출은 한번으로 끝나지 않고 내부 함수를 연쇄적으로 호출하면서 종료된다. 특히 SPA 어플리케이션의 경우 리액트가 전체 컴포넌트를 렌더링하는 작업, 혹은 서버 사이드 어플리케이션에서 리액트가 하이드레이션으로 페이지에 이벤트를 입히는 작업은 여러 함수를 호출한 뒤에야 마무리된다. 이처럼 메인 스레드에서 연쇄적으로 일어나는 작업을 한눈에 보기에 매우 적합하다.

여기서 일어나는 긴 작업을 알아본다고 가정하자.

먼저 긴 작업을 하나 선택하고 긴 작업의 세부 내역을 보면 2개의 영역이 존재한다.

함수의 세부 영역을 살펴보면 '작업', '스크립트 평가', '마이크로 태스크 실행'은 자바스크립트 엔진과 연관된 내용으로 실제 코드와 연관된 내용은 그 밑에서 확인 가능하다.

해당 영역을 클릭하면 실행된 함수 코드를 살펴볼 수 있다. 하지만 해당 함수가 왜 호출되었는지는 알 수가 없는데 이때 한단계 아래로 더 내려가보면

해당 함수가 존재하는 파일명을 볼 수 있고 해당 파일에서 개발자가 작성한 코드 또한 볼 수 있다.

이를 통해 어떻게 함수가 호출되었는가를 유추해볼 수 있다.
