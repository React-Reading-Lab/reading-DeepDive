# 깃허브 100% 활용하기

깃허브는 무료 Git 저장소 서비스를 시작으로 패키지를 저장할 수 있는 이미지 레지스트리 서비스인 GitHub Packages, 지라(Jira)와 같이 프로젝트를 관리할 수 있게 도와주는 GitHub Projects, 간단한 웹사이트를 운영할 수 있는 GitHub Pages, 그리고 인공지능 코딩 어시스턴트 서비스인 GitHub CodeSpace까지 다양한 서비스를 제공한다. 

## 깃허브 액션으로 CI 환경 구축하기

CI(Code Integration)는 코드의 변화를 모으고 관리하는 코드 중앙 저장소에서, **여러 기여자가 기여한 코드를 지속적으로 빌드하고 테스트해 코드의 정합성을 확인하는 과정**을 뜻한다. 

CI의 핵심은 **저장소에서 코드의 변화가 있을 때마다 전체 소프트웨어의 정합성을 확인하기 위한 작업을 자동으로 실행**해야 한다는 것이다.

여기서 자동으로 실행해야 하는 작업이란 테스트, 빌드 ,정적 분석, 보안 취약점 분석 등이 있다. 

과거 이 CI 환경을 구축하기 위해 가장 자주 쓰인 솔루션은 젠킨스(Jenkins)다. 젠킨스는 CI에 필요한 다양한 기능을 제공하는 무료 솔루션이었지만 사용하는 데 번거로운 측면이 많았다. 

- 설치형 솔루션이었기에 별도 서버를 구축해야 했다.
- 젠킨스 자체는 편리하고 많은 플러그린을 통해 다양한 기능을 통합할 수 있었지만 설치 및 유지보수가 번고롭다는 단점이 있었다.

이러한 젠킨스의 대안으로 떠오르고 있는 것이 바로 **깃허브 액션**이다. 깃허브 액션은 깃허브에서 출시한 SaaS로, 깃허브 저장소와 함께 사용할 수 있는 강력한 도구다. 

깃허브 액션의 본래 목적은 **깃허브 저장소를 기반으로 깃허브에서 발생하는 다양한 이벤트를 트리거 삼아 다양한 작업을 할 수 있게 도와주는 것**이다. 

- 깃허브의 어떤 브랜치에 푸시가 발생하면 빌드를 수행한다.
- 깃허브의 특정 브랜치가 메인 브랜치 대상으로 풀 리퀘스트가 열리면 빌드, 테스트, 정적 분석을 수행한다.

즉, 깃허브를 둘러싼 다양한 이벤트를 기반으로 깃허브에서 제공하는 가상 환경에서 사용자가 원하는 작업을 수행할 수 있도록 도와주는 서비스다. 

이러한 특징을 활용하면 다른 CI/CD(Continuous Integration/Continuous Delivery) 솔루션을 대체할 수 있다는 것이 널리 알려지게 되면서 깃허브 액션이 CI/CD 서비스로서 각광받게 됐다. 

### 깃허브 액션의 기본 개념

깃허브 액션에서 자주 언급되는 개념은 다음과 같다.

- 러너(runner) : 파일로 작성된 깃허브 액션이 실행되는 서버를 의미. 특별히 지정하지 않으면 공용 깃허브 액션 서버를 이용하며, 별도의 러너를 구축해 자체적으로 운영할 수 있다.
- 액션(action) : 러너에서 실행되는 하나의 작업 단위를 의미한다. yaml 파일로 작성된 내용을 하나의 액션으로 볼 수 있다.
- 이벤트(event) : 깃허브 액션의 실행을 일으키는 이벤트를 의미한다. 개발자의 필요에 따라 한 개 이상의 이벤트를 지정할 수 있다. 또한 특정 브랜치를 지정하는 이벤트도 가능하다.
    - pull_request : PR과 관련된 이벤트로서, PR이 열리거나, 닫히거나, 수정되거나, 할당되거나, 리뷰 요청되는 등의 PR 관련 이벤트를 의미
    - issues : 이슈와 관련된 이벤트로서 이슈가 열리거나, 닫히거나, 삭제되거나, 할당되는 등 이슈와 관련된 이벤트를 의미한다.
    - push : 커밋이나 태그가 푸시될 때 발생하는 이벤트를 의미
    - schedule : 저장소에서 발생하는 이벤트와 별개로 특정 시간에 실행되는 이벤트를 의미한다.
        - 여기서 말하는 시간은 cron에서 사용되는 시간이다.
        - cron이란 유닉스 계열 운영체제에서 실행되는 시간 기반 잡 스케쥴러다. 다음과 같은 형식을 취한다. `5 4 * * * : 매일 4시 5분에 실행. 분, 시간, 일, 월, 요일 순으로 표현하며, *는 모든 값을 의미한다.`
        - `본인이 원하는 시간대를 표현해 보고 싶다면 crontab guru를 방문해보자.`
- 잡 (jobs) : 잡이란 하나의 러너에서 실행되는 여러 스텝의 모음을 의미한다. 하나의 액션에서 여러 잡을 생성할 수 있으며, 특별히 선언한 게 없다면 내부 가상머신에서 각 잡은 병렬로 실행된다.
- 스텝(steps) : 잡 내부에서 일어나는 하나하나의 작업을 의미. 셸 명령이나 다른 액션을 실행할 수도 있다. 이 작업은 병렬로 일어나지 않는다.

요약하자면, **스텝들을 엮어서 잡을 만들고, 이러한 여러 개의 잡은 병렬로 실행되며, 이러한 잡을 하나 이상 모아둔 것을 액션이라고 한다. 그리고 이 액션을 실행하는 것이 러너다.**

### 깃허브 액션 작성하기

액션을 작성하려면 저장소의 루트에 `.github/workflows` 폴더를 생성하고 내부에 파일을 작성하면 된다.

파일명은 마음대로 지정할 수 있다. yaml 파일 작성을 위해 확장자는 `.yml` 또는 `.yaml`로 해야 한다.

```jsx
name : chapter7 build
run-name : ${{ github. actor}} has been added new commit.

on : 
	push : 
		branches-ignore : 
			- 'main'
			
jobs : 
	build : 
		runs-on : ubuntu-latest
		steps : 
			- uses : actions/checkout@v3
			- uses : actions/setup-node@v3
				with : 
					node-version : 16
			- name : 'install dependencies'
				working-directory : ./chapter7/my-app
				run : npm ci
			- name : 'build'
				working-directory : ./chapter7/my-app
				run : npm run build
```

저장소에 Prettier가 설치돼 있다면 yaml 파일도 함께 포함시켜 코드 스타일을 유지하는 것이 좋다. 

예시로 작성한 액션은 어떤 Next.js 앱의 빌드를 확인하는 CI 액션이다. 해당 파일을 `./github/workflows/build.yaml`이라는 이름으로 저장한 다음, 별도 브랜치에서 푸시하고 풀 리퀘스트를 만들면 PR 페이지에서 CI가 작동한 내역을 확인할 수 있다.

- github PR 페이지에서 Details를 누르면 해당 액션의 실행 결과를 알 수 있는데, 해당 로그는 시간이 지나면 사라지므로 일정 시간 이후에도 보려면 별도의 조치가 필요

#### yaml 파일 내 각 항목 의미

- name : 액션의 이름. 필수 값은 아니지만, 액션을 구별하는 데 도움이 된다.
- run-name : 액션이 실행될 때 구별할 수 있는 타이틀명. 필수 값음 아니다. 다만 예제와 같이 `github.actor` 를 활용해 어떤 사람이 해당 액션을 트리거했는지 정도를 구별
- on : 필수 값. 언제 이 액션을 실행할지 정의. 예제에서는 원격 저장소의 푸시가 발생했을 때 실행하도록 했으며, main 브랜치에 푸시가 발생했을 때는 실행X
- jobs : 필수 값. 해당 액션에서 수행할 잡을 의미. 한 개 이상 설정 가능하며, 여러개를 설정하면 병렬로 실행됨 **jobs**의 하위 항목은 무조건 들여쓰기로 구분해야 한다.
    - [jobs.build](http://jobs.build) : 임의로 지정 가능한 이름. name과 같은 역할을 한다. 위 예제에서는 jobs에 1개 이상의 작업이 있고, 그 중 하나의 작업이 build 라는 사실을 알 수 있음
    - jobs.build.runs-on : 어느 환경에서 해당 작업이 실헹될지 결정. 별도의 러너를 설정하고 싶지 않고, 깃허브에서 제공하는 서버를 쓰고 싶다면 ubuntu-latest를 선언하면 된다.
        - 커스텀 러너를 쓰고 싶다면 저장소의 `Setting-Actions-Runners` 에서 추가 가능
    - [jobs.build](http://jobs.build).steps : 해당 잡에서 순차적으로 수행할 작업을 정의
        - `uses : actions/checkout@v3` : 해당 스텝에서 작업을 `actions/checkout@v3` 을 사용해서 작업하겠다는 것을 의미. `actions/checkout@v3` 은 깃허브에서 제공하는 기본 액션으로, 별도 파라미터를 제공하지 않으면 해당 브랜치의 마지막 커밋을 기준으로 체크아웃한다.
            - 최신 코드를 기준으로 작동해야 하는 CI 액션에서는 필수적으로 사용된다.
        - `uses : actions/setup-node@v3` : 해당 스텝에서 작업을 `actions/setup-node@v3` 을 사용해서 작업하겠다는 것을 의미한다. 이 역시 깃허브에서 제공하는 기본 액션으로, 해당 러너에 Node.js를 설치한다.
            - with.node-version.16 을 함께 지정했는데, 이름에서 유추할 수 있듯이 Node.js 16 최신 버전을 설치한다. 해당 프론트엔드 프로젝트가 배포되는 Node.js 버전에 맞춰  작성.
        - `name : 'install dependencies'` : 해당 스텝의 명칭을 지정했다. 여기서는 의존성을 설치하는 작업을 수행한다.
            - `working-directory` 는 터미널의 cd 명령과 비슷한 역할을 한다. 뒤이어 수행할 작업을 해당 디렉터리에서 수행하겠다는 의미다. (그냥 루트에서 실행해도 된다면 따로 지정하지 않아도 괜찮음.
            - run을 통해 수행할 작업을 명시. 여기서는 의존성을 설치하기 위해 npm ci 선언.
        - `name : 'build'` : CI를 위한 작업. git checkout, Node.js 설치, 의존성 설치까지 마무리했으니 마지막 작업으로 빌드를 수행한다. `npm run build`를 실행해 프로젝트를 빌드.

#### 액션 작성

위 예제에서는 간단하게 build 액션을 만들어보았지만, 완벽한 것은 아니다. push 마다 빌드가 발생하면 액션이 굉장히 많이 실행되기 때문에 트리거를 조정할 필요도 있고, Yarn이나 pnpm을 쓴다면 별도로 `pnpm/acton-step`이나 `borales/actions-yarn`을 사용해 설치할 필요도 있다. 

- 그러나 한 가지 확실한 것은, 젠킨스를 처음부터 구축해서 사용하는 것보다는 훨신 손쉽게 CI를 구축할 수 있다는 것이다.

또한 GitHub Actions를 적절히 활용하면 다양한 작업이 가능하다.

- 앞의 예제처럼 기본적인 빌드 CI 작성, Prettier와 ESLint, 테스트 자동화는 당연히 됨
- actions/github-script를 사용해 깃허브 API를 직접 호출해 깃허브 풀 리퀘스트에 댓글을 달기
- 일정 시간마다 특정한 작업을 수행
- 배포 서비스와 연동해 자동으로 배포를 실행 및 저장소 내부에 이미지가 추가될 때마다 이미지를 최적화

#### 브랜치 보호 규칙

머지하기 전 꼭 성공해야 하는 액션이 있다면 별도로 저장소에 브랜치 보호 규칙(branch protection rule)을 추가할 수 있다.

- 해당 저장소의 `Settings  - Code and automation - Branches` 로 이동한 다음, `Add branch protecton rule`을 클릭해 브랜치 보호 규칙을 추가할 수 있음
- 예를 들어 main 브랜치에 대해,
    - `Require status checks to pass before merging` (머지하기 전에 상태 체크를 필수로 한다.) 와 와 `Require branches to be up to date before merging` (머지하기 전에 브랜치가 최신 내용인지 확인한다) 를 체크하면, **해당 브랜치가 최신 상태인지 확인하고 머지할 수 있는 기능**을 킨다. 마지막으로 꼭 실행돼야 하는 액션의 파일명을 선택하고 저장하면, 해당 액션이 성공하기 전가지는 main 브랜치에 대한 머지를 막을 수 있다. (정합성 확보 가능)

## 직접 작성하지 않고 유용한 액션과 깃허브 앱 가져다 쓰기

깃허브 액션은 비교적 작성이 쉬운 편이지만, 빌드나 린트, 테스트 외 여러가지 작업을 수행하기에는 여전히 다소 복잡할 숭  있다. 이를 위해 깃허브는 **Marketplace** 라는 서비스를 제공해 여러 사요자가 만들어 놓은 액션을 손쉽게 가져다 쓸 수 있도록 운영하고 있다.

이곳에 공개된 액션을 적절히 활용하면 앞선 action/checkout 예시처럼 복잡한 작업을 수행하는 액션을 손쉽게 가져다 사용할 수 있다. 

### 깃허브에서 제공하는 기본 액션

- actions/checkout :
    - 깃허브 저장소를 체크아웃하는 액션. 저장소를 기반으로 작업을 해야 한다면 반드시 필요.
    - 일반적으로는 아무런 옵션 없이 사용해 해당 액션을 트리거한 최신 커밋을 불러오지만, ref를 지정해 특정 브랜치나 커밋을 체크아웃할 수도 있다.
- actions/setup-node :
    - Node.js를 설치하는 액션.
    - Node.js를 사용하는 프로젝트라면 반드시 필요하다. 설치할 Node.js 버전을 지정할 수도 있다.
- **actions/github-script :**
    - GitHub API가 제공하는 기능을 사용할 수 있도록 도와주는 액션이다.
    - GitHub API를 이용하면 **깃허브에서 할 수 있는 대부분의 작업을 수행할 수 있으므로**, API 문서를 보는 것을 추천한다.
- actions/stale :
    - 오래된 이슈나 PR을 자동으로 닫거나 더 이상 커뮤니케이션하지 못하도록 닫는다.
    - 저장소가 오래되어 과거에 생성된 이슈나 풀 리퀘스트가 너무 많을 경우 정리하는데 도움이 됨.
- actions/dependency-review-actoin :
    - 의존성 그래프에 대한 변경, 즉 `package.json, package-lock.json, pnpm-lock.yaml` 등의 내용이 변경됐을 때 실행되는 액션이다.
    - 의존성을 분석해 보안 또는 라이선스에 문제가 있다면 이를 알려준다.
- github/codeql-action :
    - 깃허브 코드 분석 솔루션인 `code-ql`을 활용해 저장소 내 코드의 취약점을 분석해준다.
    - languages 에 javascript만 설정해 두면 JS와 TS를 모두 검사하므로, 특정 스케쥴에 맞춰서 실행하거나 CI로 활용할 수 있다.

#### calibreapp/image-actions 

잘 구축된 프로젝트의 경우 별도의 CDN을 사용해 이미지를 제공하기도 하지만, 매우 중요한 이미지거나 혹은 아직 CDN을 구축하지 못한 경우 등은 이미지를 저장소 내부에 두고 함께 관리하곤 한다. 

이러한 이미지들은 사용자에게 불편함을 주지 않는 선에서 가장 작은 파일로 관리될 필요가 있으며, 이에 대한 최적화를 제공하는 액션이다.

#### lirantal/is-website-vulnerable

특정 웹사이트를 방문해 해당 웹사이트에 라이브러리 취약점이 존재하는지 확인하는 깃허브 액션이다. 

Snyk라는 솔루션을 기반으로 작동하며, 앞서 소개한 액션과는 다르게 `실제로 웹사이트를 방문해서 웹사이트에 노출되고 있는 라이브러리`를 분석한 결과를 알려준다. 

이 경우, 개발자의 컴퓨터에서 설치만 되고 실제 배포에 포함되지 않은 devDependencies나 번들링 과정에서 트리쉐이킹으로 인해 사라진 코드는 취약점으로 진단되지 않는다.

#### Lighthouse CI

구글에서 제공하는 액션이다. 라이트하우는 CI를 기반으로 실행할 수 있도록 도와준다.

이 액션을 사용하면 프로젝트의 URL을 방문해 라이트하우스 검사를 실행한다.

이를 통해 현재 머지 예정인 웹사이트의 성능 지표를 측정할 수 있다.

## 깃허브 Dependabot으로 보안 취약점 해결하기

깃허브에서 제공하는 강력한 기능 중 하나는 Dependabot으로, 의존성에 문제가 있다면 이에 대해 문제를 알려주고 가능하다면 해결할 수 있는 풀 리퀘스트까지 열어준다. 

깃허브의 Dependabot을 활용해 프로젝트의 보안 위협을 제거하는 방법을 알아보자.

### package.json의 dependencies 이해하기

먼저, package.json의 의존성과 버전이 무엇인지 알아야 한다. 

#### 버전

- 유의적 버전(semantic versioning) 의 정의는 다음과 같다.
    - 버전은 주, 부, 수로 구성돼 있으며 각각의 정의는 다음과 같다.
        - 기존 버전과 호환되지 않게 API가 바뀌면 “주 버전”을 올리고,
        - 기존 버전과 호환되면서 새로운 기능을 추가할 때는 “부 버전”을 올리고,
        - 기존 버전과 호환되면서 버그를 수정한 것이라면 “수 버전”을 올린다.
    - 예를 들어 `16.0.0` 이라는 버전이 `16.0.1` 이 됐다면 버그를 수정한 것이다. `16.1.0`이 됐다면 새로운 기능이 추가됐으며(기존 기능을 사용하는 방법은 바뀌지 않음), `17.0.0` 이 됐다는 것은 16.0.0과 호환되지 않도록 제공하는 API에서 무언가 변경이 일어난 것이다.
- 이 외에 중요한 점들이 몇가지 더 있다.
    - 특정 버전으로 패키지를 배포하고 나면 그 버전의 내용은 절대 변경하지 말아야 한다. (변경사항이 있으면 반드시 새로운 버전으로 배포)
    - 주 버전 0은 초기 개발을 위해 쓴다. 이 버전은 아무 때나 마음대로 바꿀 수 있다. 이 공개 API는 안정판으로 보지 않는 게 좋다. (ex. Recoil. 어느 날 0.7.6 이던게 0.8.0으로 올라갔다면 이는 기능이 추가된 것 뿐 아니라 API 스펙이 변경됐을 수도 있다. 그만큼 0으로 시작하는 버전의 라이브러리는 실험 버전이므로 주의 가 필요하다.)
    - 수 버전은 반드시 그 이전 버전 API와 호환되는 버그 수정의 경우에만 올린다. 버그 수정은 잘못된 내부 기능을 고치는 것이라 정의한다.
        - 만약 버그 수정이 API 스펙 변경을 동반한다면 반드시 주 버전을 올려야 한다.
- npm은 이러한 버전에 대해 나름의 규칙을 정의해뒀다. 주로 사용하는 버전 방식은 다음과 같다.
    - react@16.0.0 : 버전 앞에 아무런 특수 기호가 없다면 정확히 해당 버전에 대해서만 의존.
    - react@^16.0.0 : 16.0.0과 호환되는 버전을 의미. 호환된다는 뜻은 0보다 높은 부 버전에 대해서는 호환된다는 가정 하에 상위 버전을 설치할 수 있다는 것을 뜻함.
        - 즉, 여기서 가능한 버전은 16.0.0 부터 17.0.0 미만이 된다.
    - react@~16.0.0 : 패치 버전에 대해서만 호환되는 버전을 의미.
        - 즉, 여기서 가능한 버전은 16.0.0 부터 16.1.0 미만의 모든 버전이다.
- 단, **유의적 버전은 어디까지나 개발자들 간의 약속일 뿐, 정말로 해당 API의 버전이 이 유의적 버전에 맞춰 구현돼 있는지는 알 수 없다.** npm은 이에 대해 보증해주지 않는다.

#### 의존성 

`package.json` 에서 dependencies란 npm 프로젝트를 운영하는 데 필요한 자신 외의 npm 라이브러리를 정의해 둔 목록이다. JSON 형식으로 작성돼 있으며, 주로 dependencies와 devDependencies로 구성돼 있다.

그리고 peerDependencies도 있지만, 이는 주로 라이브러리에서 사용된다.

- dependencies : package.json에서 npm install을 실행하면 설치되는 의존성이다. 해당 프로젝트를 실행하는 데 꼭 필요한 패키지가 여기에 선언됨
- devDependencies : package.json에서 npm install을 실행하면 설치되는 의존성. npm install 패키지명 —save-dev를 실행하면 devDependencies에 추가됨. 프로젝트 실행에는 필요하지 않지만, 개발 단계에서 필요한 패키지들을 여기에 선언.
- peerDependencies 는 주로 서비스보다는 라이브러리와 패키지에서 자주 쓰이는 단위다. 이는 직접적으로 해당 패키지를 require하거나 import 하지는 않지만, 호환성으로 인해 필요한 경우를 의미한다.
    - 예시로, 재사용 가능한 훅을 제공하는 패키지를 만든다고 가정해보자. 이 경우 실제 react를 import 하는 일은 없을 수 도 있지만, React 16.8.6 버전 이상이 반드시 필요하다.
    
    ```jsx
    {
    	"peerDependencies" : {
    		"react" : ">=16.8",
    		"react-dom" : ">=16.8"
    	}
    }
    ```
    

> [!NOTE] 하지만 devDependencies와 dependencies를 나누는 것에 의문을 제기하는 목소리가 있다.
>
> 이유 1. dependencies로 설치했든 dev-로 설치했든 모두 node_module에 동일하게 설치된다. 그리고 실제로 이 중에서 실제 서비스에 배포해야 하는 라이브러리인지를 결정하는 것은 **번들러**다. 
>
> - 번들러가 코드의 시작점부터 각 파일 간의 종속성을 판단한 다음, 필요한 파일을 빌드하는 과정을 거쳐 하나의 결과물로 만든다.
> - 즉, 위의 분류 기준은 앱 최종 결과물에는 전혀 영향을 미치지 않는 것이다.
> 
> 이유 2. 복잡해진 개발 파이프라인이다. 과거에는 npm install로 모든 패키지를 설치하고, npm install —only=production 으로 실행해 필요한 패키지만 빠르게 설치하는 전략이 유효했다. 하지만 최근 앱 개발에서는 이런 식으로 하면 tsc가 실행되지 못하는 등의 이슈로 시작은 커녕 빌드조차 불가능하다. 
>
> ---
> 
> 그럼에도 둘의 구분에 의미가 있긴 하다.
> - npm에 업로드할 패키지를 개발한다면 이러한 두 의존성 구분은 매우 중요해진다. (dependencies에 있는 패키지들만 모두 최종 패키지 결과물에 포함되게 해야 함.)


### Dependabot으로 취약점 해결하기

1. 취약점이 있는 예제 앱을 만들어보는데, package.json에 2019년 쯤에 만들어진 그 당시의 최신 라이브러리들을 활용해 의존성을 설치해본다.
2. 그리고 이 package.json을 기준으로 npm install. (설치만 했을 뿐인데 각종 vulnerabilities를 발견했다고 메시지가 우수수 뜰 것이다.) 
3. Dependabot 실행을 확인하기 위해 원격 저장소에 push. 이렇게 하면, 원격 저장소 상단에서 노란색 박스로 의존성에 여러 문제가 있다고 Dependabot이 알려준다.
4. 배너의 ‘See Dependabot alerts’를 누르면 구체적으로 어떤 의존성에 문제가 있는 지 확인할 수 있다.

Dependabot은 취약점을 Critical, High, Moderate, Low의 네 단계로 분류한다.
(이후 더 자세한 내용은 P574)

Dependabot이 경고하는 문제에 대해 계속해서 관심을 가져야 한다. 서비스에 기능을 출시하는 것만큼이나 중요한 것은 안전한 서비스를 만드는 것이고, 개발자는 이에 대한 책임을 지니고 있다. 

물론 경고 표시되는 많은 이슈가 실제 서비스의 보안 위협으로 이어지지 않을 수도 있지만, 그중에는 정말로 긴급하게 수정해야 하는 이슈도 있을 수 있다.

마지막으로,  깃허브 Dependabot은 이슈를 찾는 용도로만 활용하고 절대 완벽하게 수정해 준다고 맹신해서는 안된다. 

- Dependabot이 제안하는 풀 리퀘스트를 무작정 머지해서는 안되고, 꼭 자세히 내용을 살펴봐야 한다.

# 리액트 애플리케이션 배포하기

모든 서비스가 그렇듯, 코드가 실제로 사용자에게 제공되려면 실제 인터넷 망에 배포하는 과정이 필요하다. 

자체적인 IT 인프라가 구축돼 있어 해당 인프라를 사용하는 큰 회사도 있는 반면, 스타트업과 같이 비교적 규모가 작아 자체 인프라를 구축하기 어려운 경우는 아마존 웹 서비스나 구글 클라우드 플랫폼, 마이크로소프트 애저 등 클라우드 서비스를 활용하는 업체들도 있다. 

여기서는 리액트 앱을 가장 손쉽게 배포하도록 도와주는 3가지 SaaS 서비스를 알아보고, 각각의 특징을 비교해보자. 

(배포하는 앱은 create-react-app과 create-next-app으로 작성됐다고 가정한다.)

## Netlify

웹 앱을 배포할 수 있도록 도와주는 클라우드 컴퓨팅 서비스다. 2014년부터 시작한 서비스로, Heroku와 함께 가장 널리 알려진 정적 웹사이트 배포 서비스다. 

- 팀 생성 : Netlify에서 팀은 서비스의 기본 단위다.
- Import an existing project : 해당 버튼을 눌러 배포할 웹 앱이 있는 저장소를 불러온다.
- 만약 배포하려는 앱이 next 기반이라면 리액트 앱을 배포하는 것보다 설정이 더 필요하다.
    - 기본적으로 Netlify는 정적인 웹사이트를 배포하고 서비스하기 위해 탄생한 반면, Next.js는 next export를 사용해 정적인 웹사이트를 만즐지 않는 이상 일반적으로는 서버가 필요한 서버 사이드 앱을 서비스하므로 추가적인 설정이 필요한 것.
    - 이를 위해 가장 먼저 할 일은 Next.js 앱 루트에 `netlify.toml` 파일을 생성하는 것이다.
        - toml은 Tom’s Obvious, Minimal Language 의 약자로 최소한의 설정 관련 내용을 작성하기 위해 만들어진 문법이다. YAML과 매우 유사한 구조다.

## Vercel

Vercel은 Next.js를 비롯한 Turborepo, SWC를 만든 회사이며, Netlify와 비슷한 클라우드 플랫폼 서비스다. 

Netlify 대비 몇 가지 장점을 가진 덕분에 대안으로 떠오르고 있다.

- Vercel 또한 가입한 후 팀을 생성해야 한다. 하지만 팀은 유료 서비스이므로, 개인 계정으로 생성하면 Netlify의 Starter와 비슷한 Hobby 계정을 만들어 무료로 진행할 수 있다.
- Netlify와 마찬가지로 빌드와 배포가 이뤄져야 하는 루트 디렉터리를 선택하는데, 직접 입력하는 게 아니라 UI에서 특정 디렉터리를 선택할 수 있게 되어있다. (단, 해당 디렉터리를 선택한다고 프로젝트 설정이 같이 따라오지 않으므로 ‘Framework Preset’에서 반드시 원하는 프레임워크를 선택해야 한다.
    - 프레임워크를 선택하면 일반적으로 사용되는 빌드 명령어, 배포 위치, 배포 명령어까지 함께 선택할 수 있다.
    - 이후 Deploy를 누르면 배포가 시작된다.
- 별도 플러그인을 설치해해야 했던 Netlify와 다르게 Vercel은 Next.js 서비스를 별도의 설정 없이 배포 가능하다.

## DigitalOcean

미국의 클라우딩 컴퓨팅, 호스팅 플랫폼 업체다. 앞서 소개한 Vercel, Netlify와 비슷하게 저장소를 바탕으로 바로 배포할 수 있는 서비스를 제공한다.

다양한 리소스에 대해 문서화가 매우 상세하게 돼 있고, 자체 블로그도 운영하면서 개발과 관련된 포스팅을 자주 올리고 있다. 

- 서비스에 접속한 후 Create App을 눌러 앱을 생성한다.
- 이후 깃허브를 연결하고, 연결한 깃허브 에서 배포를 원하는 저장소, 브랜치, 소스 디렉터리의 경로를 설정한다. AutoPlay 항목을 체크하면 해당 브랜치에 푸시가 일어날 때마다 자동으로 재배포가 일어난다.

Vercel과 Netlify는 정적인 웹사이트 배포에 초점을 두고 있다면, DigitalOcean은 AWS와 Google Cloud Platform 과 비슷하게 조금 더 다양한 클라우드 컴퓨팅 서비스를 제공한다.

# 리액트 애플리케이션 도커라이즈하기

과걸에는 웹 앱을 배포하기 위해 직접 장비를 준비하고, 해당 장비에 앱 구동에 필요한 각종 파일을 설치하고 소스를 다운로드해서 설치했다면 요즘은  앱을 하나의 컨테이너로 만들어서 빠르게 배포하는게 일반적이다.

이 컨테이너를 만드는데 사용되는 것이 바로 도커(Docker)이다.

### 리액트 앱을 도커라이즈 하는 방법

앱을 도커 이미지로 만드는 과정을 **도커라이즈(dockerize)**라고 한다. 쉽게 얘기해서, 앱을 신속하게 구축해 배포할 수 있는 상태로 준비하는 것을 말한다. 

#### 도커란?

도커 홈페이지의 메타 태그 중 `<description>` 을 살펴보면 도커가 스스로를 어떤 서비스라고 정의하는 지 확인할 수 있다.

**도커는 개발자가 모던 앱을 구축, 공유, 실행하는 것을 도와줄 수 있도록 설계된 플랫폼이다. 도커는 지루한 설정 과정을 대신해 주므로 코드를 작성하는 일에만 집중할 수 있다.**

도커는 앱을 빠르게 배포할 수 있도록 앱을 ‘컨테이너’라는 단위로 패키징하고, 이 컨테이너 내부에서 앱이 실행될 수 있도록 도와준다. 도커는 이 컨테이너를 바탕으로 독립ㄹ된 환경에서 앱이 항상 일관되게 실행할 수 있도록 보장한다.

#### 도커 용어

- 컨테이너 : 도커의 이미지를 실행한 상태를 컨테이너라고 한다. 이 컨테이너가 바로 독립된 공간이며, 이미지가 목표하는 운영체제, 파일 시스템, 각종 지원 및 네트워크 등이 할당되어 실행될 수 있는 독립된 공간이 생성된다.
- Dockerfile : 어떤 이미지 파일을 만들지 정의하는 파일이다. 이 파일을 빌드하면 이미지를 만들 수 있으며, 흔히 ‘도커 이미지화한다’라고 할 때 가장 먼저 하는 것이 바로 이 도커 파일을 만드는 것이다.
- 태그 : 이미지를 식별할 수 있는 레이블 값을 의미한다. 일반적으로 `이름:태그명` 형태로 구성돼 있다.
    - 대표적인 이미지인 `ubuntu:latest`를 예로 들면, ubuntu는 이미지 이름이고 latest는 태그명이다. 즉, 해당 태그는 ubuntu의 latest 이미지를 의미한다.
- 리포지터리 : 이미지를 모아두는 저장소. 앞서 언급했던 이름에 다양한 태그로 지정된 이미지가 모여있는 저장소다.
- 레지스트리 : 리포지터리에 접근할 수 있게 해주는 서비스. 대표적인 레지스트리로는 도커 허브(Docker Hub)가 있다.
    - 이 레지스트리에는 다양한 리포지터리가 있으며, 이 리포지터리에서 사용ㅈ바는 자신이 원하는 이미지를 내려받아 사용할 수 있다.

#### 자주 쓰는 도커 cli 명령어

여기서 언급하는 대부분의 명령어는 도커 데스크톱의 GUI 인터페이스에서 제공하는 기능으로, 도커 데스크톱이 설치된 로컬 환경에서는 직접 쓸 일이 많지 않은 명령이다. 

그러나 도커 데스크톱이 없는 명령줄 기반 환경에서도 도커를 써야 할 경우가 있으므로 주요 명령어 몇 가지 정도는 알아두는 것이 좋다.

- docker build
    - Dockerfile을 기준으로 이미지를 빌드하는 작업. 일반적으로 태그를 부여하는 옵션인 -t와 함께 많이 사용된다.
        - `docker build -t foo:bar ./` 는 현재 ./ 에 있는 Dockerfile을 기준으로 이미지를 빌드하고, 해당 이미지명에 `foo:bar` 라는 태그를 붙이는 것을 의미한다.
- docker push
    - 이미지나 리포지터리를 도커 레지스트리에 업로드하는 과정을 의미한다.
        - `ducker push yceffort/foo:bar` 는 yceffort라는 사용자 계정에 foo:bar 이미지를 푸시하는 것을 말한다. 별도 설정이 돼 있지 않다면 기본적으로 도커 허브에 업로드한다.
- docker tag
    - 이미지에 태그를 생성하는 명령어다. `docker tag 원본이미지:태그 변경할_이미지:태그` 형태로 실행한다.
    - 한 가지 유념해야할 점은 이름을 수정하는게 아니라 기존 이미지에 새로운 태그를 붙인다는 것이다.
- docker inspect
    - 이미지나 컨테이너의 세부 정보를 출력하는 명령어. `docker inspect {이미지명|컨테이너명}` 으로 세부 정보를 원하는 이미지명이나 컨테이너 명령어를 입력하면 된다.
- docker run
    - 이미지를 기반으로 새로운 컨테이너를 실행하는 명령어다. 웹 앱을 실행하는 이미지를 만들었다면 이 명령어를 통해 컨테이너를 만들어 웹 앱을 컨테이너 내부에서 작동하게끔 할 수 있다.
- docker ps
    - 현재 가동 중인 컨테이너 목록을 확인할 수 있다. —all 과 함께 실행한다면 현재 가동 중이지 않은 멈춘 컨테이너도 확인할 수 있다.
- docker rm
    - docker rm {이미지명} 으로 컨테이너를 삭제할 수 있다. `docker stop {이미지명}` 으로 해당 컨테이너를 중지시키고 삭제해야 한다.