# 리액트 17과 18의 변경 사항 살펴보기

## 리액트 17버전 살펴보기

리액트 17버전은 16버전과 다르게 새롭게 추가된 기능이 없으며 호환성이 깨지는 변경 사항, 즉 기존에 사용하던 코드의 수정을 필요로 하는 변경 사항을 최소화했다는 점을 가장 큰 특징으로 꼽는다.

16버전에서 17버전으로의 버전 업은 큰 부담 없이 할 수 있는 작업이라 볼 수 있다. 구체적으로 어떤 변경점이 있는지 살펴보자.

### 리액트의 점진적인 업그레이드

9.2절 ‘깃허브 100% 활용하기’에서 유의적 버전(semantic version)이 무엇인지 이야기한 바 있다. 즉, 리액트 16버전에서 17로의 업데이트는 기존 버전인 16에서 더 이상 호환되지 않는 API가 있거나 새로운 리액트 17을 사용하는 데 있어 이전과 작동 방식이 달라질 수 있기 때문에 단행된 주 버전 업데이트다. 
리액트도 이런 유의적 버전을 기반으로 업데이트를 거치고 있다. 즉, 새로운 주 버전이 릴리스되면 이전 버전에서의 API 제공을 완전히 중단해 버리고, 전체 앱을 새롭게 업그레이드하기를 요구하고 있었다.

- 이는 새롭게 API를 작성하는 리액트 개발팀 입장에서는 편리하면서도 유용한 전략이지만, 오래된 코드 베이스를 기반으로 돌아가는 실제 웹 앱에는 그다지 좋지 못한 일이다.
    - 새로운 리액트 주 버전이 릴리즈됐을 경우, 어떤 API 수정이 있는지 일일이 확인해 적용해야 한다.
    - 지원을 중단한 API를 어떻게 고쳐야 할 지 파악해야 한다.
- 이런 이유로 레거시 앱을 관리하는 개발자는 항상 선택의 기로에 놓여 있었다. 전체 웹 서비스가 새로운 버전으로 완전히 넘어가버리거나, 계속 현재에 머물러 있어야 한다. **이러한 작업에 중간은 없다.**

#### 하지만,

리액트 17 버전부터는 점진적인 업그레이드가 가능해진다. 리액트 17을 설치하고, 이후에 리액트 18로 업데이트하는 상황을 가정해보자. 리액트 18에서 제공하는 대부분의 기능을 사용할 수도 있지만 일부 기능에 대해서는 리액트 17에 머물러 있는 것이 가능해진다. 

- 즉, 전체 앱 트리는 리액트 17이지만 일부 트리와 컴포넌트에 대해서만 리액트 18을 선택하는 **점진적인 버전 업이 가능해진 것**이다.
- 물론 버전이 서로 다른 리액트가 두 개 존재해야하므로 한 개가 있을 때보다 관리 지점이 늘어나지만, 리액트 버전을 올리기에는 너무 부담이 되는 큰 앱의 경우에는 충분히 고려 해 볼 만한 선택지일 수 있다.

이러한 **점진적인 업데이트를 지원하기 위한 리액트의 일부 컴포넌트 변경**이 리액트 17 업데이트의 주요 변경 사항 중 하나다.

- 리액트 17 앱은 내부에서 리액트 16을 게으르게(lazy) 불러온다. 불러오는 과정에서 리액트 16을 위한 별도의 루트 요소를 만들고, 여기에 불러온 리액트 16 모듈을 렌더링하는 구조로 구성돼있다.
- 이렇게 불러온 결과, 서로 렌더링하는 과정에서 버전의 불일치로 인한 에러도 발생하지 않고 하나의 웹사이트에서 두 개의 리액트가 존재하게 됐다.
    - 그리고 이 두 개의 리액트 루트는 단 하나만 존재하는 컴포넌트와 훅을 서로 불러와서 사용할 수 있다. 즉, 리액트 16과 17 버전을 모두 지원하는 컴포넌트나 훅이라면 버전이 다른 두 리액트에서도 무리없이 사용 가능하다. (Context도 마찬가지다.)

리액트 팀에서는 이를 `어디까지나 한꺼번에 업그레이드가 불가능한 상태에서만 차선택`으로, 여전히 **리액트 버전을 한꺼번에 업데이트하는 게 복잡성 측면에서 좋다고 언급한다.

### 이벤트 위임 방식 변경

먼저, 리액트에서 이벤트가 어떻게 추가되는지를 이해해보자.

```jsx
import { useEffect, useRef } from 'react' 

export default function Button() {
	const buttonRef = useRef<HTMLButtonElement | null>(null);
	
	useEffect(()=>{
		if (buttonRef.current) {
			buttonRef.current.onClick = function click() {
				alert('안녕하세요!');
			}
		}
	}, []);
	
	function 안녕하세요() {
		alert('안녕하세요!');
	}
	
	return (
		<>
			<button onClick={안녕하세요}>리액트 버튼</button>
			<button ref={buttonRef}>그냥 버튼</button>
		</>
	)
}
```

먼저, ‘리액트 버튼’은 일반적으로 리액트 앱에서 DOM 이벤트를 추가하는 방식으로 onClick 이벤트를 추가했다. 반면 ‘그냥 버튼’의 이벤트는 직접 DOM을 참조해서 가져온 다음, DOM의 onclick에 직접 함수를 추가하는 고전적인 이벤트 핸들러 추가 방식을 사용했다.

위 두 버튼을 개발자도구에서 확인하면 아래와 같다.

- 그냥 버튼 : 해당 버튼의 이벤트 리스너에 ‘click’이라는 이름으로 추가돼 있음
- 리액트 버튼 : `<button>` 의 onClick 이벤트에 noop이라는 핸들러가 추가돼 있음
    - 여기서 noop 함수는 문자 그대로(no operation) 아무런 일도 하지 않는다. (텅 빈 함수다.)
    - 리액트는 이벤트 핸들러를 해당 이벤트 핸들러를 추가한 각각의 DOM 요소에 부탁하는 것이 아니라, **이벤트 타입(click, change) 당 하나의 핸들러를 루트에 부착**한다.
        - 이를 **이벤트 위임**이라고 한다.
        - 캡쳐(capture) : 이벤트 핸들러가 트리 최상단 요소에서 부터 시작해서 실제 이벤트가 발생한 타깃 요소까지 내려가는 것
        - 타깃(target) : 이벤트 핸들러가 타깃 노드에 도달하는 단계. 이 단계에서 이벤트가 호출됨
        - 버블링(bubbling) : 이벤트가 발생한 요소에서부터  시작해 최상위 요소까지 다시 올라감
        

        > [!NOTE] 이벤트 위임이란?        💡
        > 위와 같은 이벤트 단계의 원리를 활용해 이벤트를 상위 컴포넌트에만 붙이는 것. 
        > 이벤트 위임을 사용하면 많은 이점을 얻을 수 있다.
        > - 자식 요소가 추가 또는 삭제되더라도 이벤트 핸들러를 수정할 필요가 없다.
        > - 이벤트 추가를 한 번만 하면 되므로 좀 더 효율적으로 관리할 수 있다.
        

리액트는 최초 릴리스부터 이러한 이벤트 위임을 적극 사용해왔다. 리액트는 이벤트 핸들러를 각 요소가 아닌 `document` 에 연결해서 이벤트를 더 효율적으로 관리한다.

#### 하지만 리액트 17버전에서는…

하지만 리액트 17부터는 이러한 이벤트 위임이 모두 document가 아닌, **리액트 컴포넌트의 최상단 트리, 즉 루트 요소**로 바뀌었다. 

- 앞서 이야기한 점진적인 업그레이드 지원, 그리고 다른 바닐라 JS 코드 또는 jQuery 등이 혼재돼 있는 경우 혼란을 방지하기 위해서다.
    - 만약 리액트 16 을 사용한 앱에서 이벤트를 달았다면, 모든 이벤트 핸들러는 document에 부착될 것이다. 이 경우 이벤트 전파를 막는 `e.stopPropagation`을 실행했을 때, 모든 이벤트는 이미 document에 있으므로 document의 이벤트 전파는 막을 수 없게 된다.

⇒ 아래의 의문들이 있지만 이벤트 위임을 각 루트 별로 처리하게 해서 혼선 방지하겠다는 의도는 알겠음…


### import React from ‘react’ 가 더 이상 필요 없다 : 새로운 JSX transform

16 버전까지는 JSX 변환을 사용하기 위해 코드 내에서 React를 사용하는 구문이 없더라도 `import React from 'react'` 가 필요했다.

```jsx
const Component = {
	<div>
		<span>hello world</span>
	</div>
}
//위 처럼 React가 안보이는 코드도, 트랜스파일을 거치면 아래처럼 된다.
var  Component = React.createElement(
	'div',
	null,
	React.createElement('span', null, 'hello world')
);
```

하지만 17 부터는 바벨과 협력해 이러한 import 구문 없이도 JSX를 변환할 수 있게 됐다. 

- 해당 업데이트는 불필요한 import 구문을 삭제해 번들링 크기를 약간 줄이고, 컴포넌트 작성을 더욱 간결하게 해줬다.

17 버전에서는 위의 코드가 트랜스파일 이후 아래처럼 변환된다.

```jsx
'use strict'

var _jsxRuntime = require('react/jsx-runtime');

var Component = (0, _jsxRuntime.jsx)('div', {
	children : (0, _jsxRuntime.jsx)('span', {
		children : 'hello world',
	}),
})

// 콤마 연산자는 왼쪽부터 오른쪽 순서대로 처리한다. 
// 즉, 위에서는 0을 처리 후 _jsxRuntime.jsx를 처리.
// 결과적으로 (0, _jsxRuntime.jsx)는 jsx 메소드를 반환. 여기서 바인딩이 끊긴다.
```

React.createElement가 사라진 것도 눈에 띄지만 한 가지 더 주목해 볼 만한 것은 바로 require() 구문이다. 이제 JSX를 변환할 때 필요한 모듈인 `react/jsx-runtime` 을 불러오는 require 구문도 같이 추가되므로 `import React from 'react'` 를 작성하지 않아도 된다.

그 외 이점으로는 다음과 같은 것들이 있다.

- `react/jsx-runtime` 을 `React.createElement` 와 비교해서 내부 소스코드를 직접 살펴보면 두 함수 모두 ReactElement를 반환하지만, 리액트 내부 코드를 살펴보면 `react/jsx-runtime` 의 jsx 쪽이 훨씬 더 내부 로직이 간결하다.
- import React 구문이 사라져서 번들 사이즈가 조금이나마 줄어든다.

### 그 밖의 주요 변경 사항

#### 이벤트 풀링 제거

과거 리액트 16에서는 이벤트 풀링이라는 기능이 있었다. 리액트에는 이벤트를 처리하기 위핸 SyntheticEvent라는 이벤트가 있는데, 이 이벤트는 브라우저의 기본 이벤트를 한 번 더 감싼 이벤트 객체다. 

- 리액트는 이렇게 브라우저 기본 이벤트가 아닌 한번 래핑한 이벤트를 사용하기 때문에, 이벤트가 발생할 때마다 이 이벤트를 새로 만들어야 했다.
    - 그 과정에서 메모리 할당 작업이 매번 일어날 수 밖에 없었다. 메모리 누수를 방지하기 위해 이벤트를 주기적으로 해체해야하는 번거로움도 있었다.
- 여기서 **이벤트 풀링**이란, SyntheticEvent 풀을 만들어서 이벤트가 발생할 때마다 가져오는 것을 의미했다.

즉, 이벤트 풀링 시스템에서는 다음과 같이 이벤트가 발생했다.

1. 이벤트 핸들러가 이벤트를 발생시킨다.
2. 합성 이벤트 풀에서 합성 이벤트 객체에 대한 참조를 가져온다.
3. 이 이벤트 정보를 합성 이벤트 객체에 넣어준다.
4. 유저가 지정한 이벤트 리스너가 실행된다.
5. 이벤트 객체가 초기화되고 다시 이벤트 풀로 돌아간다.

언뜻 보기에는 이벤트 풀에 있는 합성 이벤트를 반복적으로 사용할 수 있어 효과적으로 보이지만, 이벤트를 받아오고 종료되자마자 다시 초기화하는(null로 변경하는) 방식은 별로 직관적이지 않다. 다음 코드를 통해 해당 문제를 이해할 수 있다.

```jsx
export default function App() {
		const [value, setValue] = useState('');
		function handleChange(e : ChangeEvent<HTMLInputElement>) {
			setValue(()=>{
				return a.target.value;
			});
		}
		
		return <input onChange={handleChange} value={value} />
}

// 위 코드는 아래와 같은 에러를 발생시킨다.
// Cannot read properties of null (reading 'value')
// Warning: This synthetic event is reused for performance reasons. 
// if you're seeing this, you're accessing the property 'target' on ~ (중략)
```

에러가 발생하는 이유는, 리액트 16버전 이하에서는 위에서 설명한 이벤트 풀링 방식을 사용하기 때문에, 이벤트 핸들러를 호출한 SyntheticEvent가 이후 재사용을 위해 null로 초기화되기 때문이다.

따라서 위의 경우나 비동기 코드 내부에서 SyntheticEvent인 e에 접근하기 위해서는 추가적인 작업인 `e.persist()` 같은 처리가 필요했다.

비동기 코드로 이벤트 핸들러에 접근하기 위해서는 이러한 방식으로 별도 메모리 공간에 합성 이벤트 객체를 할당해야 한다는 점, 그리고 모던 브라우저에서는 이와 같은 방식이 성능 향상에 크게 도움이 안 된다는 점 때문에 이벤트 풀링 개념은 현재 사라졌다.

17버전 이후부터는, 이벤트 핸들러 내부에서 이벤트 객체에 접근할 때 비동기든 동기든 상관없이 일관적으로 코딩할 수 있게 됐다. 

### useEffect 클린업 함수의 비동기 실행

리액트의 uesEffect에 있는 클린업 함수는 리액트 16버전까지는 동기적으로 처리됐다. 동기적으로 실행되기 때문에 이 클린업 함수가 완료되기 전까지는 다른 작업을 방해하므로 불필요한 성능 저하로 이어지는 문제가 존재했다. 

하지만 리액트 17 버전부터는 **화면이 완전히 업데이트된 이후에 클린업 함수가 비동기적으로 실행된**다.

- 더 정확하게는, 컴포넌트의 커밋 단계가 완료될 때까지 지연된다.

즉, 화면이 업데이트가 완전히 끝난 이후에 실행되도록 바뀌었으며, 이로써 약간의 성능적인 이점을 볼 수 있게 됐다.

### 컴포넌트의 undefined 반환에 대한 일관적인 처리

리액트 16과 17 버전은 컴포넌트 내부에서 undefined를 반환하면 오류가 발생한다. 이는 의도치않게 잘못된 반환으로 인한 실수를 방지하기 위해서였다. 

하지만, 16에서는 forwardRef나 memo에서 undefined를 반환하는 경우에는 별다른 에러를 발생시키지 않았다. 

- 17 버전에서는 위 경우에도 에러가 발생하도록 조치되었고,
- 18 버전부터는 undefined를 반환해도 에러가 발생하지 않는다.

## 리액트 18 버전 살펴보기

리액트 17에서 점진적인 업그레이드를 위한 준비를 했다면, 리액트 18에서는 리액트 17에서 하지 못했던 다양한 기능들이 추가됐다. 그 중 가장 큰 변경점은 바로 동시성 지원이다. 

이 동시성 지원에 대한 고민은 수년 전부터 있었고, 리액트 개발 팀 이외에 다양한 개발자들의 의견을 듣고자 별도의 워킹 그룹을 구축할 정도로 심혈을 쏟았다. 

### 새로 추가된 훅 살펴보기

- useId
    - useId는 컴포넌트 별로 유니크한 값을 생성하는 새로운 훅이다. 이 유니크 값을 생성하는 것은 생각보다 쉽지 않은 일이다.
        - 하나의 컴포넌트가 여러 군데에서 재사용되는 경우를 고려해야 한다.
        - 리액트 컴포넌트 트리에서 컴포넌트가 가지는 모든 값이 겹치지 않고 다 달라야 한다.
        - 서버 사이드 렌더링 환경에서 하이드레이션이 일어날 때도 서버와 클라이언트에서 동일한 값을 가져야 에러가 발생하지 않는다.
            
            ```jsx
            export default function UniqueComponent() {
            	return <div>{Math.random()}</div>
            }
            
            // 위 코드가 서버 사이드에서 렌더링되어 클라이언트에 제공된다고 할 때, 
            // 아래의 에러가 발생한다. 서버에서 렌더링했을 때의 random() 결과와 
            // 클라이언트에서 하이드레이션을 했을 때의 random() 결과가 다르기 때문이다.
            
            // Text content did not match. Server : "0.3236~" Client : "0.9375~"
            ```
            
    - useId를 사용하면 클라이언트와 서버에서 불일치를 피하면서 컴포넌트 내부의 고유한 값을 생성할 수 있다.
    - useId가 생성하는 값은 `:` 로 감싸져 있는데, 이는 CSS 선택자나 querySelector에서 작동하지 않도록 하기 위한 의도적인 결과다.
        - 또한, 앞글자가 R이면 서버에서, r이면 클라이언트에서 생성된 값이다.

- useTransition
    - UI 변경을 가로막지 않고 상태를 업데이트할 수 있는 리액트 훅이다. 이를 활용하면 상태 업데이트를 긴급하지 않은 것으로 간주해 무거운 렌더링 작업을 조금 미룰 수 있다.
    
    ```jsx
    import { useState, useTransition } from 'react'
    // ...
    
    export default function TabContainer() {
    	const [ inPending, startTransition] = useTransition();
    	const [ tab, setTab] = useState<Tab>('about');
    	
    	function selectTab() {
    		startTransition(()=>{
    			setTab(nextTab);
    		});
    	}	
    	
    	return (
    		<>
    			{/* ... */}
    			{isPending ? (
    				'로딩 중'
    			) : (
    				<>
    					{tab === 'about' && <About />}
    					{tab === 'posts' && <Posts />}
    					{tab === 'contact' && <Contact />}
    				</>
    			)}
    		</>
    	);
    }
    ```
    
    - isPending은 상태 업데이트가 진행 중인지를 확인할 수 있는 boolean이고, startTransition은 긴급하지 않은 상태 업데이트로 간주할 set 함수를 넣어둘 수 있는 함수를 인수로 받는다.
    - 위와 같이 useTransition을 사용하면 각 탭이 오래 걸리는 작업이더라도, 렌더링이 블로킹되지 않으며 로딩 되는 동안 ‘로딩 중’ 이 표시되게 할 수 있다. 도중에 다른 탭으로 이동하면 기존 렌더링은 중단되고 새 탭 렌더링이 시작된다.
    - useTransition은 리액트 18의 변경 사항의 핵심 중 하나인 **동시성(concurrency)**을 다룰 수 있는 새로운 훅이다.
    - 사용 시 주의할 점은 다음과 같다.
        - startTransition 내부는 반드시 setState와 같은 상태를 업데이트하는 함수와 관련된 작업만 넘길 수 있다.
        - startTransition으로 넘겨주는 상태 업데이트는 다른 모든 동기 상태 업데이트로 인해 실행이 지연될 수 있다. 예를 들어, 타이핑으로 인해 setState가 일어나는 경우 타이핑이 끝날 때까지 useTransition으로 지연시킨 상태 업데이트는 일어나지 않는다.
        - startTransition으로 넘겨주는 함수는 반드시 동기 함수여야 한다. 이 안에 setTimeout과 같은 비동기 함수를 넣으면 제대로 작동하지 않는다. 이는 startTransition이 작업을 지연시키는 작업과 비동기로 함수가 실행되는 작업 사이에 불일치가 일어나기 때문이다.

- useDeferredValue
    - 리액트 컴포넌트 트리에서 리렌더링이 급하지 않은 부분을 지연할 수 있게 도와주는 훅이다.
    - 특정 시간 동안 발생하는 이벤트를 하나로 인식해 한 번만 실행하게 해주는 디바운스와 비슷하지만, 디바운스 대비 useDeferredValue가 가진 장점이 있다.
        - 디바운쓰는 고정된 지연 시간을 필요로 하지만, useDeferredValue는 지연된 렌더링을 수행한다. 그러므로 이 지연된 렌더링은 중단할 수도 있으며, 사용자의 인터랙션을 차단하지도 않는다.
    - useDeferredValue와 useTransition의 차이는 useTransition은 state 값을 업데이트하는 함수를 감싸서 사용하는 반면, useDefferredValue는 state 값 자체만을 감싸서 사용한다는 것이다. 둘 다 지연된 렌더링을 한다는 점에서 동일한 역할을 하므로, 상황에 맞는 방법을 선택하면 된다.

- useSyncExternalStore
    - 이 훅은 동시성을 다루는 기능이 도입되면서 리액트 18버전부터 생길 수 있는 **테어링(tearing)** 현상 문제를 해결하기 위한 훅이다.
    - 테어링이란 영어로 찢어진다 라는 의미로, 리액트에서는 하나의 state 값이 있음에도 서로 다른 값을 기준으로 렌더링되는 현상을 의미한다.
    - React 17 버전의 useSubscription은 React 18의 해당 훅으로 완전히 대체되었다.
        - (구독 기능을 동시성 제어 과정에서 발생하는 state의 불일치를 해결하기 위한 방법으로 사용하게 된듯 하다.)
    - 외부에 상태가 있는 데이터에는 반드시 useSyncExternalStore를 사용해 값을 가져와야 startTransition 등으로 인한 테어링 현상이 발생하지 않는다.

- useInsertionEffect
    - useSyncExternalSotre가 상태 관리 라이브러리를 위한 훅이라면, useInsertionEffect는 CSS-in-js 라이브러리를 위한 훅이다.
    - CSS의 추가 및 수정은 브라우저에서 렌더링하는 작업 대부분을 다시 계산해 작업해야 하는데, 이는 리액트 관점으로 본다면 모든 리액트 컴포넌트에 영향을 미칠수도 있는 매우 무거운 작업이다.
    - 따라서 리액트 17과 styled-components에서는 클라이언트 렌더링 시에 이러한 작업이 발생하지 않도록 서버 사이드에서 스타일 코드를 삽입했다. 하지만 이 작업을 훅으로 처리하는 것은 지금까지 쉽지 않았는데, 훅에서 이러한 작업을 할 수 있도록 도와주는 것이 useInsertionEffect다.
    - useInsertion은 DOM이 실제로 변경되기 전에 동기적으로 실행된다. 훅의 실행 순서는 다음과 같다.
        - useInsertionEffect → useLayoutEffect → useEffect
    - 리액트에서 권고하는 것처럼, 해당 훅은 useSyncExternal과 마찬가지로 실제 앱 코드 작성 시에는 쓸 일이 거의 없으므로, 라이브러리를 작성하는 경우가 아니라면 참고만 하고 실제  앱  코드에서는 가급적 사용하지 않는게 좋다.

### react-dom/client

- createRoot : 기존의 react-dom에 있던 render 메소드를 대체할 새로운 메소드다.
- hydrateReoot : 서버 사이드 렌더링 앱에서 하이드레이션을 하기 위한 새로운 메소드다. React DOM 서버 API와 함께 사용된다.

### react-dom/server

- renderToPipeableStream : 리액트 컴포넌트를 HTML로 렌더링하는 메소드다. 스트림을 지원하는 메소드로, HTML을 점진적으로 렌더링하고 클라이언트에서는 중간에 script를 삽입하는 등의 작업을 할 수 있다.
    - renderToNodeStream의 문제는 무조건 렌더링을 순서대로 해야 하고, 그리고 그 순서에 의존적이기 때문에 이전 렌더링이 완료되지 않으면 이후 렌더링도 끝나지 않는다는 것이다. 따라서 렌더링 중간에 오래 걸리는 작업이 있다면, 그 작업 때문에 나머지 렌더링도 덩달아 지연되는 문제가 있었다.
        - 그러나 해당 메소드를 사용하면 순서나 오래 걸리는 렌더링에 영향 받을 필요 없이 빠르게 렌더링을 수행할 수 있다.

### 자동 배치(Automatic Batching)

자동 배치는 리액트가 여러 상태 업데이트를 하나의 리렌더링으로 묶어서 성능을 향상시키는 방법을 의미한다. 예를 들어, 버튼 클릭 한 번에 두 개 이상의 state를 동시에 업데이트한다면, 자동 배치에서는 이를 하나의 리렌더링으로 묶어서 수행할 수 있다.

- 또한, Promise를 사용할 때도 고의로 실행을 지연시키는 sleep 함수를 호출하지 않는 이상 버전과 상관없이 한 번만 렌더링한다.
- 이는 리액트 17 이하의 과거 버전의 경우 이벤트 핸들러 내부에서는 자동 배치 작업이 이뤄지고 있었지만 Promise, setTimeout 과 같은 비동기 이벤트에서는 자동 배치가 이뤄지고 있지 않았기 때문이다.

즉, 동기와 비동기 배치 작업에 일관성이 없었고, 이를 보완하기 위해 리액트 18 버전부터는 루트 컴포넌트를 createRoot를 사용해서 만들면 모든 업데이트가 배치 작업으로 최적화할 수 있게 됐다.

### 더욱 엄격해진 엄격 모드

리액트 엄격 모드는 리액트에서 제공하는 컴포넌트 중 하나로, 리액트 앱에서 발생할 수도 있는 잠재적인 버그를 찾는 데 도움이 되는 컴포넌트다. 

이 엄격 모드에서 수행하는 모드는 모드 개발자 모드에서만 작동하고, 프로뎍션 모드에서는 작동하지 않는다. 

엄격 모드에서 하는 작업은 다음과 같다.

- 더 이상 안전하지 않은 특정 생명주기를 사용하는 컴포넌트에 대한 경고
    - UNSAFE_ 가 붙은 생명주기 메소드를 사용하면 경고 로그 발생
- 문자열 ref 사용 금지
    - ref 속성에 문자열 값을 넣으면 경고로 로그 발생
- findDOMNode에 대한 경고 출력
    - findDOMNode를 사용해 실제 DOM 요소의 참조를 가져오는 방식은 현재 권장되지 않으므로, 사용 시 에러 발생
- 구 Context API 사용 시 발생하는 경고
- 예상치 못한 부작용(side-effect) 검사
    - 다음의 내용을 의도적으로 이중 호출
        - 클래스 컴포넌트의 constructor, render, shouldComponentUpdate, getDerivedStateFromProps
        - 클래스 컴포넌트의 setState의 첫 번째 인수
        - 함수 컴포넌트의 body
        - useState, useMemo, useReducer에 전달되는 함수
    - 이런 식으로 두 번 호출하는 이유는, 함수형 프로그래밍의 원칙에 따라 모든 리액트 컴포넌트는 항상 순수하다고 가정하기 때문이다.  엄격 모드에서는 컴포넌트가 항상 순수한 결과물을 내고 있는지 개발자에게 확인시켜 주기 위해 두 번 실행된다.

#### 리액트 18에서 추가된 엄격 모드

컴포넌트가 최초에 마운트될 때 자동으로 모든 컴포넌트를 마운트 해제하고 두번째 마운트에서 이전 상태를 복원한다. (이 또한 오직 개발모드에서만 적용된다.)

### Suspense 기능 강화

Suspense는 리액트 16.6 버전에서 실험 버전으로 도입된, 컴포넌트를 동적으로 가져올 수 있게 도와주는 기능이다. 리액트 18 버전에 이르러 Suspense는 실험 단계에서 벗어나 정식으로 지원됐다. 

### 인터넷 익스플로어 지원 중단에 따른 추가 폴리필 필요

18버전부터 React는 다음과 같은 최신 JS 기능을 사용할 수 있다는 가정 하에 배포된다.

- Promise, Symbol, Object.assign

하지만 이러한 세 기능을 지원하지 않는 브라우저에서 서비스해야 한다면, 이 세 가지 기능을 위한 폴리필을 반드시 추가해야 한다.

### 그 밖에 알아두면 좋을 변경사항

- 이제 컴포넌트에서 undifined를 반환해도 에러가 발생하지 않는다. undefined 반환은 null과 동일하게 처리된다.
- `<Suspense fullback={undefined}>` 도 null과 동일하게 처리된다.
- renderToNodeStream이 지원 중단됐다. 그 대신 renderToPipeableStream을 사용하는 것이 권장된다.