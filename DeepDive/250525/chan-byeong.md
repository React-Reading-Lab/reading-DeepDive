# 5. 리액트와 상태 관리 라이브러리

## 5.1 상태 관리 라이브러리의 필요성

### 상태란 무엇일까?

정의 : 어떠한 의미를 지니는 값이며, 어플리케이션의 시나리오에 따라 지속적으로 변경될 수 있는 값을 의미한다.

예시 :

1. UI : 웹 어플리케이션에서 상태라 함은 상호 작용이 가능한 모든 요소의 현재 값을 의미한다.

2. URL : 브라우저에서 관리되고 있는 상태 값으로 주로 파라미터를 통해 상태를 관리한다.

3. Form : 값이 유효한가, 로딩 중인가, 제출되었는가, 등 모두 상태로 관리된다.

4. 서버에서 가져온 값 : API를 통해 서버에서 받아온 값도 상태라 볼 수 있다.

현재 어플리케이션의 크기가 커짐에 따라 관리해야하는 상태도 복잡해지고 어려워지고 있다.

이를 해결하기 위해 상태 관리가 어떤식으로 발전해왔는지 살펴보자

## 5.2 리액트 상태 관리의 역사

### Flux 패턴

2014년 Flux 패턴과 이를 기반으로 한 라이브러리인 `Flux`가 등장한다.

이 당시 웹 개발 상황을 간단하게 살펴보면

MVC 패턴이 일반적으로 사용되고 있었다. 하지만 어플리케이션의 크기가 커짐에 따라 MVC 패턴의 복잡도는 증가했다.

`Flux`를 개발한 페이스북 팀에서는 MVC 패턴의 복잡성의 원인을 `양방향 데이터 바인딩`이라고 생각했다.

모델과 뷰가 서로에게 간섭이 가능하기 때문에 이로인한 복잡도가 증가하고 예측가능성이 떨어질 수 있다.

이를 개선하기 위해 양방향이 아닌 단방향 데이터 흐름으로 변경한 것이 바로 `Flux`이다.

`Action -> Dispatcher -> Model -> View`

- Action: 어떠한 작업을 처리할 액션과 그 액션 발생 시 함께 포함시킬 데이터를 의미한다. 액션 타입과 데이터를 각각 정의해 이를 디스패처로 내보낸다.

- Dispatcher: 액션을 스토어로 보내는 역하릉ㄹ 한다. 콜백 함수 형태로 앞서 액션이 정의한 타입과 데이터를 모두 스토어에 보낸다.

- Store: 여기에서 실제 상태에 따른 값과 상태를 변경할 수 있는 메서드를 가지고 있다. 액션의 타입에 따라 어떻게 이를 변경할 지 정의되어 있다.

- View: 리액트의 컴포넌트에 해당하는 부분으로 스토어에서 만들어진 데이터를 활용하여 화면을 렌더링하는 역할을 한다.
  또한 뷰에서도 사용자의 입력이나 행위에 따라 상태를 업데이트 하고자 할 수 있다. 이 경우에는 `View`에서 `Action`을 호출할 수 있다.

단방향 데이터 흐름을 활용하면 데이터의 흐름이 모두 `Action`이라는 한 방향으로 줄어들기 때문에 어플리케이션의 크기가 커지더라도 파악하기 수월하다는 장점이 있지만, 모든 상태 업데이트가 `Action`의 호출을 통해 이루어지기 때문에 작성해야하는 코드의 양이 많아진다는 단점도 존재한다.

추가로 리액트는 대표적인 데이터 단방향 바인딩을 기반으로 하기 때문에 `Flux`패턴과 잘 맞기도 했다.

### 리덕스의 등장

리덕스도 초기에는 `Flux` 패턴을 활용한 라이브러리였으나 여기서 `Elm` 아키텍처를 도입했다.

### Elm 아키텍처

Elm 아키텍처는 3가지로 이루어져 있다.

- Model: 어플리케이션의 상태를 의미하낟.

- View: 모델을 표현하는 HTML을 의미한다.

- Update: 모델을 수정하는 방식을 의미한다.

_리덕스는 하나의 상태 객체를 스토어에 저장해두고, 이 객체를 업데잍하는 작업을 디스패치해 업데이트를 수행한다._

이러한 리덕스의 등장으로

하나의 글로벌 상태 객체를 통해 이 상태를 하위 컴포넌트에 전파할 수 있기 때문에 props drilling 문제를 해결할 수 있었고, 스토어가 필요한 컴포넌트라면 단지 `connect`만 쓰면 스토어에 바로 접근할 수 있었다.

리덕스의 불편한 점

하나의 객체를 변경하고 싶어도 많은 작업이 필요하다.

먼저 어떠한 액션인지 타입을 선언해야 하고, 이 액션을 수행할 creator 함수를 만들어야 한다. 그리고 dispatcher와 selector도 필요하고 새로운 상태가 어떻게 기존의 리듀서 내부에서 어떤 식으로 변경되야 할지 혹은 새로 만들어야할 지도 결정해야 했다.

### ContextAPI와 useContext

v16.3에서 전역 상태를 하위 컴포넌트에 주입할 수 있는 새로운 Context API를 출시 했다.

Context API를 사용하면 props로 넘겨주지 않더라도 Context Provider가 주입하는 상태를 바로 사용할 수 있다.

그러나 Provider의 하위 컴포넌트가 모두 렌더링된다는 단점이 존재했다. 그래서 Context API를 상태 관리가 아닌 단순 상태 주입을 도와주는 기능이라고 소개했다.

### 훅의 탄생 그리고 React Query과 SWR

두 라이브러리는 흔히 서버 상태라 불리는 상태 관리를 도와주는 라이브러리이다. API 호출을 통해 받아온 상태를 캐싱하여 사용하기 때문에 불필요한 API 요청을 줄일 수 있고, 원하는 컴포넌트에서 캐시에 저장된 상태를 받아와 사용할 수도 있다.

### Recoil, Zustand, Jotai, Valtio에 이르기까지

_훅을 활용해 작은 크기의 상태를 효율적으로 관리할 수 있도록 해준다._

## 5.2 리액트 훅으로 시작하는 상태 관리

### 5.2.1 가장 기본적인 방법 useState, useReducer

두 개의 훅은 지역상태 관리를 위해 만들어졌다.

지역 상태라는 한계 때문에 여러 컴포넌트에 걸쳐 공유하기 위해서는 컴포넌트 트리의 재설계가 필요하다

추가적으로 트리의 깊이가 깊어질 경우 props를 다단계로 넘겨주어야 한다는 불편함도 존재한다.

### 5.2.2 지역 상태의 한계를 벗어나보자: useState의 상태를 바깥으로 분리하기

함수 외부에서 상태를 참조하고 이를 통해 렌더링까지 자연스럽게 일어나게 하려면 다음과 같은 조건을 만족해야한다는 결론에 도달한다.

1. 꼭 window나 global에 있어야 할 필요는 없지만 컴포넌트 외붕 어딘가에 상태를 두고 여러 컴포넌트가 같이 쓸 수 있어야 한다.

2. 이 외부에 있는 상태를 사용하는 컴포넌트는 상태의 변화를 알아차릴 수 잇ㅆ어야 하고 상태가 변화될 때마다 리렌더링이 일어나서 컴포넌트를 최신 상태값 기준으로 렌더링해야 한다. 이 상태 감지는 상태를 변경시키는 컴포넌트 뿐 만아니라 해당 상태를 참조하는 모든 컴포넌트에서 동일하게 동작해야한다.

3. 상태가 원시값이 아닌 객체인 경우 그 객체에 내가 감지하지 않는 값이 변한다 하더라도 리렌더링이 일어나서는 안된다.
   즉, 내가 객체 내에 참조하지 않는 값이 변경될 때는 리렌더링이 일어나지 않아야한다.

이를 구현하기 위해서 `Publish` - `Subscribe` 디자인 패턴을 활용할 수 있다.

전역적으로 관리할 상태를 `Store`라는 곳에 정의해두고 이를 활용하는 컴포넌트를 해당 스토어를 `Subscribe`하는 구조이다.

이때 상태가 변경될 때마다 이를 구독중인 컴포넌트에게 상태값 변경을 알려주기 위해서 구독 시 컴포넌트는 `callback`함수도 함께 등록한다.

만약 스토어에 존재하는 상태의 변경이 일어날 경우 store는 구독 중인 컴포넌트의 `callback`을 실행시켜 상태가 변경됨을 알릴 수 있다.

이때 `callback` 함수는 컴포넌트의 렌더링을 일으킬 수 있는 함수여야 한다. 예를 들어 useState의 setter를 `callback`으로 등록해두면 상태가 변경되어 `callback` 호출 시 자연스럽게 구독 중인 컴포넌트는 렌더링될 것이다.

위의 방식은 상태가 원시값인 경우는 정상적으로 동작하지만 상태가 객체인 경우 컴포넌트가 사용하지 않는 값이 업데이트 되더라도 렌더링이 발생하는 경우가 생긴다.

이를 개선하여 다시 한번 코드를 작성해보면 대략적으로 다음과 같다.

_위의 코드에서 `useStore`를 통해 컴포넌트가 스토어 구독 시 인자로 스토어의 어떤 인자를 구독할 지 알려주어 상태가 객체인 경우 항상 렌더링되는 현상을 막을 수 있다._ (362p)

이러한 방식으로 작동하는 코드를 리액트의 `useSubscription`을 통해 똑같이 구현이 가능하다.

`useSubscription`은 어떤 값을 구독할 지와 `callback`을 인자로 받아 설정할 수 있도록 도와준다.

후에 살펴볼 `useSyncExternalStore`를 통해서 `useSubscription`은 구현되었다.

### 5.2.3 useState와 Context를 동시에 사용해보기

_컴포넌트 별 격리된 Store를 제공하기 위해서 Context를 사용하여 컴포넌트 트리에서 단계 별로 다른 Store에 접근하도록 할 수 있다._ (390p)

## 5.2.4 상태 관리 라이브러리 Recoil, Jotai, Zustand 살펴보기

### Recoil

### Jotai

### Zustand
