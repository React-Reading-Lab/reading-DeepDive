# 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표

이번 장에서는 웹서비스의 성능을 객관적으로 평가할 수 있는 지표인 핵심 웹 지표에 대해 알아보고, 이를 리액트 앱에서 측정하는 방법도 알아보자.

## 웹사이트의 성능

웹 사이트의 성능과 사용자 경험 사이의 상관관계에 대한 데이터는 이미 널리 알려져 있다. 2019년 미국 시애틀에 있는 디지털 마케팅 에이전시 회사인 Portent의 조사에 따르면, 웹 사이트의 성능은 다음과 같은 요소에 영향을 미쳤다.

- 1초 내로 로딩되는 사이트는 5초 내로 로딩되는 사이트보다 전자상거래 전환율이 2.5배 더 높다.
- 0~5초의 범위에서, 1초 로딩이 늦어질수록 전환율은 4.42%씩 떨어진다. 즉, 5초 이상 느려지면 전환율은 20% 가까이 떨어진다.
- 페이지 로드 시간이 0 ~ 2초 사이인 페이지에서 가장 높은 전환율을 달성할 수 있다.

그리고 사용자 또한 이러한 성능에 매우 민감한 것으로 밝혀졌다.

- 소비자의 70%는 페이지 속도가 온라인 커머스 사이트를 방문하는 데 영향을 미친다고 밝혔다.
- 절반 가까운 사람이 더욱 빠르게 로딩할 수 있다면 애니메이션과 동영상이 필요 없다고 밝혔다.

분명히 과거에 비해 비교할 수 없이 모바일 기기의 성능이 향상됐고, 네트워크 속도 또한 빨라졌고, IT 서비스 업체가 서비스하는 서버, 통신 등의 물리 장비 또한 눈부시게 발전하고 있음에도 여전히 대다수의 웹사이트 방문객들은 속도에 민감하며 느린 속도에 대해 불만을 가지고 있다.

- 물론 과거의 웹사이트와 비교할 수 없을 정도로 현재의 웹사이트는 많은 정보를 제공한다. 이는 앞서 언급한 웹을 아우르고 있는 기술의 눈부신 발전 덕분이다.

하지만 많은 개발자들은 이러한 성능에 대해 크게 관심을 기울이지 않는다. 그 이유에는 여러가지가 있다.

1. 개발자의 기기는 대부분 일반적인 사용자의 평균적인 기기보다 성능이 뛰어나고, 네트워크 환경도 안정적이다. 따라서 웬만큼 잘못되지 않은 이상 성능 문제를 경험하기가 어렵다.
2. 성능을 개선하는 작업은 새로운 기능을 개발하는 것보다 쉽지도, 재밌지도 않고, 서비스를 개발하는 작업 대비 눈에 띄는 성능 향상을 기대하기도 어렵다.

그럼에도 웹사이트 개발자라면 자신이 만들고자 하는 프로덕트를 어떤 기술로 어떻게 만들 것인지 신경스는 만큼 웹사이트 성능에도 주의를 기울여야 한다.

## 핵심 웹 지표란?

핵심 웹 지표(Core Web Vital)란 구글에서 만든 지표로, 웹사이트에서 뛰어난 사용자 경험을 제공하는 데 필수적인 지표를 일컫는 용어다. 

과거에도 웹사이트의 성능 측정을 위한 다양한 도구와 여러 가지 지표가 있었지만, 뚜렷한 표준이나 측정 방법이 정해져 있지 않아 일관되게 판단하기 어려웠다. 이를 해결하기 위해 구글에서는 **사이트에서 핵심적인 웹 지표를 몇 가지로 요약하고, 이를 측정할 수 있는 방법, 그리고 ‘좋은 웹사이트’로 분류할 수 있는 기준을 명확하게 제시** 했다.

구글에서 핵심 웹 지표로 꼽는 지표는 다음과 같다.

- 최대 콘텐츠풀 페인트(LCP : Largest Contentful Paint)
- 최초 입력 지연(FID : First Input Delay)
- 누적 레이아웃 이동(CLS : Cumulative Layout Shift)

그리고 다음 두 지표는 핵심까지는 아니지만, 특정 문제를 진단하는 데 사용될 수 있다고 언급했다.

- 최초 바이트까지의 시간 (TTFB : Time To First Byte)
- 최초 콘텐츠풀 시간 (FCP : First Contentful Paint)

## 최대 콘텐츠풀 페인트(LCP)

최대 콘텐츠풀 페인트(LCP : Largest Contentful Paint)란 **페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간**을 말한다.

뷰포트는 사용자에게 현재 노출되는 화면을 의미한다. 사용자에게 노출되는 영역은 기기에 의존하므로 뷰포트 크기는 기기마다 다르다. 

- 예를 들어 모바일 기기는 PC보다 뷰포트가 작을 것이다.

그리고 이 **뷰 포트 내부**에서 **큰 이미지와 텍스트**는 다음과 같이 정의돼 있다.

- `<img>`
- `<svg>` 내부의 `<image>`
- poster 속성을 사용하는 `<video>`
- `url()`을 통해 불러온 배경 이미지가 있는 요소
- 텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소
    - 이 블록 레벨 요소에는 `<p>` , `<div>` 등이 포함된다.

이미지와 텍스트가 각각 사용자의 시점에 언제 노출됐는지를 확인하는 정확한 시점은 W3C 문서에 나와있다. 기술적인 순서로 언급돼 있지만 요약하자면 `각 엘리먼트가 등장한 시점부터 텍스트 또는 이미지가 완전히 로딩되는 시점` 으로 보면 된다.

**⇒ 즉, LCP란 사용자의 기기가 노출하는 뷰포트 내부에서 가장 큰 영역을 차지하는 요소가 렌더링되는 데 얼마나 걸리는지를 측정하는 지표인 것이다.**

- 여기서 ‘가장 큰 요소’로 고려되는 것은 앞의 5개이며, 실제 크기가 크다고 하더라도 뷰포트 영역 밖에 넘치는 요소가 있다면 해당 영역의 크기는 고려되지 않는다.
- 즉, 단순히 사용자에게 있어 로딩이란, 일단 뷰포트 영역에 보이는 부분을 기준으로 할 것이므로, 뷰포트에 메인 콘텐츠가 화면에 완전히 전달되는 속도를 기준으로 한다면 사용자는 페이지가 로딩이 완료됐다고 체감하는 시간과 매우 비슷할 것이다. 따라서 **사용자에게 페이지의 정보를 화면에 전달하는 속도를 객관적으로 판단하기 위한 지표로 만들어진 것**이 LCP이다.

### 기준 점수

LCP에서 좋은 점수란, 해당 지표가 `2.5초 내로 응답`이 오는 것이다. `4초 이내로 응답이 온다면 보통`, `그 이상이 걸리면 나쁨`으로 판단된다. 

### 개선 방안

그럼 LCP 점수를 올릴 수 있는 방법에는 무엇이 있을까?

1. 텍스트는 언제나 옳다.
- LCP에서 좋은 점수를 얻는 가장 확실한 방법은 뷰포트 최대 영역, 즉 최대 콘텐츠풀 페인트 예상 영역에 이미지가 아닌 문자열을 넣는 것이다.
- 제아무리 이미지를 최적화하더라도 추가적인 리소스 다운로드가 필요한 이미지보다 텍스트 노출이 훨신 더 빠르다.

1. 이미지는 어떻게 불러올 것인가?
- 아무리 1번 방법을 적용해보려고 해도, 기획자나 디자이너 입장에서는 사용자에게 더 강렬한 인상을 주기 위해 이미지를 사용하길 원할 것이다.
- 이때 개발자가 선택할 수 있는 이미지를 노출하는 방법에는 다음과 같이 여러가지가 있다.

```jsx
// 1) img
<img src="lcp.jpg" ... />

// 2) svg
<svg xmlns="http://www.w3.org/1000/svg">
	<image href="lcp.jpg" />
</svg>

// 3) (비디오의 경우) vide.poster
<video poster="lcp.jpg"></video>

// 4) background-image: url()
<div style="background-image: url(lcp.jpg)">...</div>
```

- 위 네 가지 방법으로 이미지 로딩 속도에 어떤 차이가 있는지 스크린샷을 찍어보면, **1번과 3번 예제 코드가 더 빠르게 완성되는 것**을 볼 수 있다.
- 각 결과의 이유는 다음과 같다.
    - 1번
        - 이미지는 브라우저의 프리로드 스캐너에 의해 먼저 발견되어 빠르게 요청이 일어난다. **프리로드 스캐너**란 **HTML을 파싱하는 단계를 차단하지 않고** **이미지와 같이 빠르게 미리 로딩하면 좋은 리소스를 먼저 찾아 로딩**하는 브라우저의 기능이다.
        - `<img>` 내부의 리소스는 이처럼 HTML 파싱이 미처 완료되지 않더라도 프리로드 스캐너가 병렬적으로 리소르를 다운로드 하므로 최대 콘텐츠풀 페인트 요소를 불러오기에 적절한 방법이다. 이는 `<picture>` 도 마찬가지다.
    - 2번 : `<svg> 내부의 <img>`
        - `<svg>` 내부의 `<img>`가 로딩이 완료되기 전까지는 최대 콘텐츠풀 페인트가 완료되지 않는다. 또한, 모든 리소스를 다 불러온 이후에 이미지를 불러온다. 이는 `<img>`와 다르다.
        - 즉, `<svg>` 내부의 `<img>` 는 프리로드 스캐너에 의해 발견되지 않아 병렬적으로 다운로드가 일어나지 않는다. 이는 결국 LCP 점수에도 악영향을 미치게 되므로 삼가하는게 좋다.
        - `<img>`가 미처 로딩되지 않은 시점, 그러니까 `<svg>` 만 로딩딘 시점에 이미 최대 콘텐츠풀 페인트가 완료된 것으로 간주하는 크롬 102 이하 버전에서의 버그가 있다. 그 이후 버전에서는 해결됨.
    - 3번 : `<video>` 의 poster
        - poster는 사용자가 video 요소를 재생하거나 탐색하기 전까지 노출되는 요소다. 이 역시 마찬가지로 프리로드 스캐너에 의해 조기에 발견되어 `<img>` 와 같은 성능을 낸다.
        - 그리고 또 한가지 알아둬야 할 사실은, 향후에 poster가 없는 video의 경우 video를 실제로 로딩해 첫 번째 프레임에 해당 poster 리소스로 대체할 예정이라는 것이다.
        - 그러므로 video가 최대 콘텐츠풀 페인트에 영향을 받을 것 같다면 poster를 반드시 넣어주는 것이 좋다.
    - 4번 : background-image
        - background-image를 비롯해서 CSS에 있는 리소스는 항상 느리다. 이러한 리소스는 브라우저가 해당 리소스를 필요로 하는 DOM을 그릴 준비가 될 때까지 리소스 요청을 뒤로 미루기 때문이다.
        - 이 말은, 최대 콘텐츠풀 페인트에도 별로 좋은 영향을 미치지 못한다는 뜻이다. 그러므로 해당 방법은 중요한 콘텐츠에는 가능한 사용하지 않는게 좋다.
    

#### 그 밖에 조심해야 할 사항

- 이미지 무손실 압축 : 당연한 이야기이다. 웹서비스의 이미지는 가능한 한 무손실 형식으로 압축해 최소한의 용량으로 서비스하는 게 좋다.
- loading=lazy : `loading-lazy`는 리소스를 중요하지 않음으로 표시하고 필요할 때만 로드하는 전략이다. `<img>` , `<ifame>` 등에 적용할 수 있지만, 문제는 최대 콘텐츠풀 콘텐츠의 이미지는 중요하지 않은 리소스로 분류해서는 안된다는 것이다.
    - 이는 그저 로딩 속도만 늦출 뿐 지표 점수에는 도움이 되지 않는다. 상대적으로 중요하지 않은 이미지에만 사용하자.
- fadein과 같은 각종 애니메이션 : 당연하게도 이미지가 그냥 뜨는 것보다 `fadeIn ease 10s` 와 같이 처리한다면 최대 콘텐츠풀 페인트도 그만큼 늦어진다.
- 클라이언트에서 빌드하지 말 것
    - 앞선 사례를 통해 알 수 있는 최적의 시나리오는, **서버에서 빌드해온 HTML을 프리로드 스캐너가 바로 읽어서 최대 콘텐츠풀 페인트로 빠르게 가져가는 것**이다.
    - 그런데, 만약 최대 콘텐츠풀 페인트에 다음과 같이 useEffect 코드가 있으면 어떻게 될까?
        
        ```jsx
        useEffect(()=>{
        	;(async function loadData() {
        		const result = await fetch('https://example.com/data');
        		if (result.ok) {
        			setShow(true); // 최대 콘텐츠풀 페인트 영역을 노출함
        		}
        	})();
        }, []);
        ```
        
        - 이 예제는 어떤 API 엔드포인트에서 응답을 받아 최대 콘텐츠풀 페인트 영역의 노출을 제어하는 시나리오다. 이렇게 되면 결국 LCP는 HTML을 다운로드한 직후가 아닌, 리액트 코드를 파싱하고 읽어서 API 요청을 보내고, 응답을 받는 만큼 늦어진다. 따라서 가능한 한 이 영역은 서버에서 미리 빌드된 채로 오는 것이 좋다.
- 최대 콘텐츠풀 리소스는 직접 호스팅
    - 가능하다면 최대 콘텐츠풀 리소스는 같은 도메인에서 직접 호스팅하는 것이 좋다. 일반적인 경우 Cloudinary 같은 이미지 최적화 서비스를 사용해 하나의 이미지에 대해 크기도 줄이고, 포맷도 변환하고, 압축해서 이미지를 관리하지만 다른 출처(origin)에서 이렇게 정제한 이미지를 가져오는 것은 최적화에 별로 좋은 영향을 미치지 않는다.
    - 왜냐하면, 이미 연결이 맺어진 현재 출처와는 다르게, 완전히 새로운 출처의 경우에는 네트워크 커넥션부터 다시 수행해야 하기 때문이다.
    - 앞서 loading-lazy의 경우와 마찬가지로 가능한 한 중요한 리소스는 직접 다루고, 그 외에 덜 중요한 리소스에 대해서만 이미지 최적화 서비스를 사용하는 식으로 관리하는 것이 좋다.
    
    > [!NOTE] CDN은 언제 유리하고, 언제 불리할까? (chat-gpt)    💡
    > ******
    > | 항목 | 설명 |
    > | --- | --- |
    > | **유리한 경우** | - 대규모 글로벌 트래픽<br /> - 같은 CDN으로 다양한 리소스 공유 시<br /> - 캐싱 효과가 높은 경우 |
    > | **불리한 경우** | - 페이지 내 핵심 콘텐츠(Above the fold 이미지 등)을 외부 CDN에서 불러올 경우<br /> - 사용자 접속 지점과 CDN 엣지 노드 거리가 먼 경우<br /> - CORS 처리 필요 시 복잡성 증가 |
    

## 최초 입력 지연(FID)

수강 신청 페이지에서 수강 신청을 할 때, 순간적으로 물린 엄청난 트래픽 때문에 웹사이트가 클릭이나 타이핑도 되지 않아 아무런 작업을 하지 못한 경험이 한 번쯤 있을 것이다. 

이처럼 촌각을 다투는 상황에서 사용자가 클릭을 비롯한 웹 상호작용을 할 수 없다면, 사용자는 웹사이트가 느리다고 생각할 수 밖에 없다.

웹 사이트 반응 속도는 웹 페이지 로딩 속도만큼 중요하다. 이러한 웹사이트의 반응성을 측정하는 지표가 **최초 입력 지연(FID : First Input Delay)이다. 

최초 입력 지연의 정의는 다음과 같다.

`사용자가 페이지와 처음 상호작용 할 때 (예: 링크를 클릭하거나 버튼을 탭하거나 사용자 지정 JS 기반 컨트롤을 사용할 때)부터 해당 상호 작용에 대한 응답으로 브라우저가 실제로 이벤트 핸들러 처리를 시작하기까지의 시간을 측정합니다.` 

모든 입력에 대해 측정하는 것이 아니며, 최초의 입력 하나에 대해서만 그 응답 지연이 얼마나 걸리는지 판단한다.

### 의미

대부분의 이벤트 핸들러에는 이벤트를 즉시 처리하기 위한 코드를 작성하는 것이 일반적이다. 그렇다면 웹사이트 내부의 반응이 늦어지는 이유는 무엇일까?

그 이유는, **대부분 해당 입력을 처리해야 하는 브라우저의 메인 스레드가 바쁘기 때문이다.**

무언가 대규모 렌더링이 일어나고 있거나, 대규모 JS 파일을 분석하고 실행하는 등 다른 작업을 처리하는 데 리소스를 할애하고 있을 때 메인 스레드는 바쁠 수 밖에 없다. 

JS 실행 환경은 ‘싱글 스레드’이기 때문에 JS가 이벤트 리스너와 같은 다른 작업을 실행할 수 없어 지연이 발생한다. 즉, 이벤트가 발생하는 시점에 최대한 메인 스레드가 다른 작업을 처리할 수 있도록 여유를 만들어 둬야 사용자에게 빠른 반응성을 보장할 수 있다.

#### 최초 입력에 대한 이해

최초 입력에 해당하는 내용에는 타이핑, 터치(클릭), 핀치 투 줌, 스크롤 등 다양하다.

이 최초 입력 지연에 대한 정의를 살펴보면, 이처럼 다양한 이벤트 중에서도 반응성에 해당하는 클릭, 터치, 타이핑 등 사용자의 개별 입력 작업에 초점을 맞추고 측정한다. 

스크롤이나 핀치 투 줌 등은 사용자의 입력이 아닌 애니메이션으로 분류해 측정 대상에서 제외한다.

구글은 **사용자 경험을 크게 4가지로 분류해 정의**한다. 이를 **RAIL**이라고 한다. 

- Response : 사용자의 입력에 대한 반응 속도. 50ms 미만으로 이벤트를 처리할 것.
- Animation : 애니메이션의 각 프레임을 10ms 이하로 생성할 것.
- Idle : 유휴 시간을 극대화해 페이지가 50ms 이내에 사용자 입력에 응답하도록 할 것
- Load : 5초 이내에 콘텐츠를 전달하고 인터랙션을 준비할 것

이 가운데 **최초 입력 지연이란 화면이 최초에 그려지고 난 후, 사용자가 웹페이지에서 클릭 등 상호작용을 수행했을 때 메인 스레드가 이 이벤트에 대한 반응을 할 수 있을 때까지 걸리는 시간을 의미**한다.

### 예제

최초 입력 지연이 발생한 예제를 살펴보자. 최대 콘텐츠풀 페인트와 다르게 최초 입력 지연은 사용자나 E2E 도구 등이 직접 클릭 등의 입력을 발생시켜야 한다. 

클릭은 2000ms 경에 일어났지만 실제 클릭에 따른 이벤트는 2600ms 경에 시작됐다면, 이는 이벤트가 발생한 시점부터 실제 함수 호출이 있기까지 500ms나 걸렸다는 뜻이다.

그 원인을 살펴보면 클릭 이벤트가 발생한 시점에 메인 스레드가 무언가 다른 작업을 하고 있다는 것을 확인할 수 있다. 

한 가지 염두해둬야 할 것은 FID는 이벤트가 처리되는 것이 얼마나 지연되는지만 판단한다는 것이다. 이벤트 핸들러의 실행 순간을 기준으로 하지, 해당 핸들러의 처리 시간은 계산하지 않는다.

만약 이벤트 핸들러의 실행 시간을 측정하고 싶다면 `Event Timing API`를 사용하는게 좋다.

### 기준 점수

최초 입력 지연의 **좋은 점수를 얻기 위해서는 100ms 이내로 응답**이 와야 하며, **300ms 이내인 경우 보통**, **그 이후의 경우에는 나쁨**으로 처리한다. 

### 개선 방안

최초 입력 지연을 개선하려면 최초 입력 지연에 가장 큰 영향을 미치는 메인 스레드에 이벤트를 실행할 여유를 줘야 한다. 

#### 실행에 오래 걸리는 긴 작업을 분리

긴 작업(Long Task)이란 말 그대로 실행을 완료하는 데 오래 걸리는 작업을 의미한다.

메인 스레드를 오래 점유해야 하는 긴 작업은 비단 최초 입력 지연뿐만 아니라 웹페이지 전반에 악영향을 미친다. 만약 실행에 오래 걸리는 작업이 있다면 몇 가지 대안을 연구해야 한다.

- 꼭 웹페이지에서 해야 하는 작업인가?
    - 만약 개발자의 최신 개발 기기에서도 오랜 시간이 소요되는 작업이라면 실제 사용자가 이용하는 경우에는 더욱 오래 걸릴 것이다. 사용자 기기의 환경과 비슷하게 메인 스레드의 성능을 의도적으로 낮추고 싶다면, 크롬의 개발자 도구를 활용하면 된다.
    - cpu와 네트워크 속도 모두 고의로 느리게 만들 수 있다.
    - 위 테스트를 통해 너무 오래 걸리는 작업이라는 판단이 들 경우, 꼭 웹페이지에서 해야 하는 작업인 지 고민해 보고, **서버로 옮길 수 있는 작업이면 서버에서 처리**하는 게 좋다.
        - 서버에서 처리하면 상대적으로 빠르고 쾌적한 환경에서 처리해 브라우저의 메인 스레드를 오래 점유하지 않게 할 수 있다.
    - 만약, **꼭 웹페이지에서 처리해야 하는 작업이라면** 해당 작업을 여러 개로 분리하는 것이 좋다. 하나의 긴 작업이 메인 스레드를 계속 점유할수록 사용자는 페이지에서 응답을 받지 못하고 있을 가능성이 크다.
        - 작업을 분리한다는 것은 단순히 실행이 오래 걸릴 것 같은 작업을 분리하는 것뿐만 아니라, 웹페이지 최초 로딩에 필요하지 않은 내용을 나중에 불러오는 것도 포함된다.
        

#### 자바스크립트 코드 최소화

- 현대의 번들링 도구들은 번들링에 필요한 코드만 모아 최종 프로덕션 JS 코드를 생성하지만, 여전히 경우에 따라 웹페이지를 불러오는 데 사용되지 않는 코드가 존재할 수 있다. 이러한 코드 또한 크롬 개발자도구에서 확인할 수 있다.
    - 크롬 개발자 도구 → 햄버거 버튼 → 도구 더보기 → 커버리지
    - 그 후 기록 버튼을 클릭하고 웹페이지를 새로고침하면 된다. 그럼 현재까지 웹페이지에 사용되지 않은 코드가 얼마나 있는 지 확인 가능하다. (물론, 특정 이벤트에 실행되는 코드 등 필요없는 코드가 아니라 우선순위에 밀리는 코드일 가능성이 높으니, 그런 시각으로 봐야 한다.)
- 폴리필(pollyfill)은 브라우저에서 지원하지 않는 기능을 사용하기 위해 웹페이지에서 직접 구현하고 집어넣는 코드를 의미한다. `Array.prototype.find` 메소드는 인터넷 EX 11 이하 버전에서는 지원하지 않는다. 이처럼 **브라우저에서 지원하지 않는 메소드를 사용하기 위해서**는 다음과 같은 폴리필이 필요하다.
    
    ```jsx
    Object.defineProperty(Array.prototype, 'find', {
    	enumerable : false,
    	configurable : true,
    	writable : true,
    	value : function(predicate) {
    		if (this == null) {
    			throw new TypeError('Array.prototype.find called on null or undefined');
    		}
    		if (typeof predicate !== 'function') {
    			throw new TypeError('predicate must be a function');
    		}
    		
    		var list = Object(this);
    		var length = list.length >>> 0;
    		var thisArg = arguments[1];
    		var value;
    		
    		for (var i=0 ; i<length ; i++) {
    			if (i in list) {
    				value = list[i];
    				if (predicate.call(thisArg, value, i, list)) {
    					return value;
    				}
    			}
    		}	
    		return undefined
    	},
    });
    ```
    
    - 이처럼 한 메소드에 들어가는 폴리필 크기는 제법 크다. 폴리필을 ‘실제 코드에서 사용하는 기준’이 아닌 ‘일단 인터넷 익스플로어 11에 없는 코드를 기준’으로 햐게 되면 폴리필 크기가 기하급수적으로 커진다.
    - 후자의 경우 모던한 JS 코드를 작성하는 데는 편할 수 있지만, 사용자에게 전달되는 코드의 크기는 기하급수적으로 커진다. 따라서 폴리필을 추가하기 전에는 반드시 두 가지를 먼저 확인해야 한다.
        - 폴리필이 필요한 환경인가?
            - 만약 인터넷 익스플로어11과 같인 구형 브라우저 환경을 지원하지 않기로 결심했다면, 대부분의 폴리필은 필요가 없다.
        - 꼭 필요한 폴리필인가?
            - 앱 여러군데에서 자주 사용되는 코드인지 반드시 확인.
            - 만약 사용하는 곳이 몇 군데 되지 않는다면 폴리필을 사용하는 것보다 직접 저수준 JS 코드를 작성해 구현하는 편이 코드 크기를 줄이는 데 도움이 될 수 있다.
    - 만약 바벨 같은 도구를 사용하고 있다면, `@babel/preset-env` 를 사용해 앱 코드에서 사용하고 있는 내용만 폴리필에 담을 수 있다. Next.js의 SWC를 사용하고 있다면 이미 SWC 내부에 구현돼 있기 때문에 별도 처리가 필요 없을 것이다.

#### 타사 자바스크립트 코드 실행의 지연

개발자가 구축한 앱에 꼭 개발자가 만든 스크립트만 들어가라는 법은 없다. Google Analytics나 Firebase와 같이 웹페이지 통계 집계를 위해 제 3자가 만든 타사 스크립트를 넣는 경우도 있다.

이러한 타사 JS 실행으로 메인 스레드가 잠시 점유되고, 이로 인해 사용자에게 안 좋은 반응성을 제공한다면 주객이 전도되는 상황인 것이다.

이러한 타사 JS는 대부분 웹페이지 로드에 중요한 자원이 아니므로, `<script/>` 의 async와 defer를 이용해 지연 불러오기를 하는 것이 좋다. 각각의 차이는 다음과 같다.

- defer
    - script에 defer 속성이 있다면 먼저 해당 스크립트를 다른 리소스와 함께 병렬로 다운로드 한다.
    - 다운로드 하는 중에도 HTML 파싱 등의 메인 스레드 작업은 멈추지 않는다.
    - 다운로드가 완료됐다 하더라도 이 스크립트의 실행은 페이지가 완전히 로딩된 이후에 맨 마지막에 실행된다.
- async
    - script에 async 속성이 있다면 마찬가지로 해당 스크립트를 다른 리소스와 함께 병렬로 다운로드 한다.
    - async 리소스의 다운로드가 완료되어 버리면 다른 리소스의 다운로드가 완료되는 것을 기다리지 않고 바로 실행한다.
    - 따라서 async 리소스의 실행 순서는 다운로드가 완료된 순서이다.
- 둘 다 없는 경우
    - script를 만나는 순간 다운로드가 우선되며, 다운로드가 완료되면 코드 실행이 우선된다. 다른 작업은 다운로드와 실행이 끝날 때까지 미뤄진다.

스크립트는 async, defer로 갈수록 실행은 뒤로 미뤄지지만 성능은 좋아진다. 따라서 타사 JS는 가능하면 async를, 더 가능하다면 defer로 지연하는 게 좋다. 

만약 광고와 같이 실제 사용자의 뷰포트 위치에 따라 불러와야 하는 컴포넌트라면 [**Intersection Observer**](https://developer.mozilla.org/ko/docs/Web/API/Intersection_Observer_API)를 이용해 뷰포트에 들어오는 시점을 불러오는 것이 좋다. 

이처럼, 사용자가 기대하지 않은 추가적인 리소스는 실행을 조금 뒤로 미뤄두고 실행하는 시점을 최적화해라.


## 누적 레이아웃 이동(CLS)

페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표를 계산하는 것이 **누적 레이아웃 이동(CLS)**다. 이 지표가 낮을 수록, 사용자가 겪는 예상치 못한 레이아웃 이동이 적어지고 더 좋은 웹이 된다.

과거 웹은 제한적인 트래픽과 리소스로 인해 제공되는 정보가 굉장히 한정적이었다. 하지만 현재의 웹사이트는, 좀 더 구체적으로 리액트로 만들어는 웹사이트는 `useEffect` 등의 사용으로 클라이언트에서 처리해야 하는 작업이 많은 편이다.

만약 useEffect에 렌더링 완료 이후 처리 완료되는 작업이 포함되어있다면, 레이아웃이 재변경되어 사용자가 보고 있던 콘텐츠의 위치가 변경되어 상호작용에 실패할 수 있다. 

최초 렌더링이 시작된 위치에서 만약 레이아웃의 이동이 발생한다면 누적 레이아웃 이동 점수로 기록된다. 하지만, 아래의 경우들은 누적 레이아웃 이동으로 계산하지 않는다.

- 누적 레이아웃 이동은 사용자의 가시적인 콘텐츠에 영향을 미쳐야 하기 때문에 뷰포트 내부의 요소에 대해서만 측정하며, 뷰포트 밖의 요소에 대해서는 측정하지 않는다.
- 단순히 요소가 추가된다고 해서 무조건 CLS로 판단하지 않으며, 다른 요소의 시작 위치에 영향을 미치지 않았다면 레이아웃 이동으로 간주하지 않는다.
- 사용자 액션으로 인해 발생한 레이아웃 이동은 점수에 포함되지 않는다.
    - 사용자가 예상할 수 있는 레이아웃 이동이기 때문이다.
    - 사용자가 아무런 동작을 하지 않았음에도 불구하고 레이아웃 이동이 발생하는 경우는 점수에 포함된다.

CLS 점수를 계산할 때 포함되는 내용은 다음과 같다.

- 영향분율 : 레이아웃 이동이 발생한 요소의 전체 높이와 뷰포트 높이의 비율을 의미.
    - 레이아웃 이동이 발생한 요소의 높이가 10이고, 예기치 않은 레이아웃 이동으로 인해 10만큼 내려갔다고 가정해보자. 이 경우 뷰포트의 높이가 100이라면, 레이아웃 이동으로 총 `10+10` 만큼 뷰포트에 영향을 미쳤으므로 이 경우 영향분율은 `(10+10)/100 = 0.2` 가 된다.
- 거리분율 : 레이아웃 이동이 발생한 요소가 뷰포트 대비 얼마나 이동했는지를 의미한다.
    - 예기치 않은 레이아웃 이동으로 인해 10만큼 내려갔고, 전체 뷰포트가 100이라면 0.1점이 된다. `10/100`
- 위 두 가지 점수를 곱해서 CLS 최종 점수를 계산한다. 위의 경우 최종 CLS 점수는 0.02점이다.

또한, 누적 레이아웃 점수는 웹을 표시하는 기기마다 차이가 있을 수 있다. 위에서 봤듯이, CLS 점수에 뷰포트의 크기가 영향을 주기 때문이다. (당연히 작은 화면일수록 유리한 점수를 얻는다.)

### 기준 점수

0.1 이하인 경우 좋음, 0.25 이하인 경우 보통, 그 외에는 개선이 필요한 나쁜 점수로 보고된다.

### 개선 방안

#### 삽입이 예상되는 요소를 위한 추가적인 공간 확포

대부분의 큰 누적 레이아웃 이동은 클리아언트에서 삽입되는 동적인 요소로 인해 발생한다. 요소의 크기가 갑자기 바뀌거나, 광고와 같은 타사 라이브러리가 브라우저에서 로드 되는 등의 작업이 주로 원인이다. 

이러한 영향을 받는 것을 미연에 방지하기 위해서는 useEffect 내부에서 요소에 영향을 미치는 작업, 특히 뷰포트 내부에서 노출될 확률이 높은 작업을 최소화 하는 것이 좋다. 아니면, useLayoutEffect 훅을 검토해보는 것도 좋다. 

- 다면 useLayoutEffect는 동기적으로 발생해 브라우저의 페인팅 작업에 영향을 미치기 때문에, 사용자에게 로딩이 오래 걸리는 것 처럼 보일 수 있다는 점을 염두해야 한다.

스켈레톤 UI처럼 미리 무언가 동적으로 뜰 것으로 예상되는 공간을 미리 확보해 두는 것도 좋은 방법이다. 하

- 하지만 이 경우는, 해당 영역이 뜨지 않는 케이스가 있다면 누적 레이아웃 이동을 피하기 어렵다.

가장 좋은 방법은 서버 사이드 렌더링이다. 서버에서 이러한 동적인 요소의 유무를 사전에 판단해 클라이언트에 HTML을 미리 제공해 준다면, 클라이언트에서는 이러한 고민을 할 필요 없이 깔끔하게 처리할 수 있다.

- 하지만 타사 스크립트에 의존해 처리하는 경우 서버 사이드 렌더링이 불가능할 수 있으므로, 이러한 경우에는 앞에서 언급한 방법들을 사용해야 한다.

#### 폰트 로딩 최적화

폰트 또한 레이아웃 이동을 일으키는 원인 중 하나다. 폰트로 인해 발생할 수 있는 문제는 크게 두 가지다.

- FOUT(flash of unstyled text) : HTML 문서에서 지정한 폰트가 보이지 않고 대체 기본 폰트로 보이고 있다가, 뒤늦게 폰트가 적용되는 현상
- FOIT(flash of invisible text) : HTML 문서에서 지정한 폰트가 보이지 않고, 기본 폰트도 없어서 텍스트가 없는 채로 있다가 뒤늦게 폰트가 로딩되면서 페이지에 렌더링되는 현상

폰트는 각각 고유의 높이와 너비를 가지고 있다. 즉, 미처 지정한 폰트가 다운로드되기 전에 텍스트를 노출해버리면, 지정 폰트가 로드된 후 폰트 변화에 따른 CLS가 있을 수 있다.

따라서 사용자 기기의 기본 폰트 외에 다른 폰트로 웹페이지를 보여주고 싶다면, 다음과 같은 점을 유념해야 한다.

- `<link>`의 preload 사용
    - `<link>` 요소의 rel=preload는 페이지에서 즉시 필요로 하는 리소스를 명시하는 기능이다. preload로 지정된 요소는 웹페이지의 생명주기에서 초기에 불러와야 하는 중요한 리소스로 간주되므로, 브라우저는 리소스를 더 빠르게 사용할 수 있도록 준비해 준다.
    - 따라서 rel=preload로 스타일이나 폰트를 지정하면 페이지의 렌더링을 가로막거나 레이아웃을 방해할 가능성이 줄어든다.
- font-family : optional
    - 폰트를 불러올 수 있는 방법은 크게 다섯 가지다.
        - auto(기본값) : 브라우저가 폰트를 불러오는 방법을 결정한다.
        - block : 폰트가 로딩되기 전까지 렌더링을 중단한다. (최대 3초) 웹 폰트의 로딩이 완료되면 비로소 폰트를 적용한다.
        - swap : 앞서 언급한 FOUT 방식이다. 우선 폴백 폰트로 글자를 렌더링한 다음, 웹 폰트의 로딩이 완료되면 웹 폰트를 적용한다.
        - fallback : 이 옵션을 사용하면 100ms간 텍스트가 보이지 않고, 그 이후에 폴백 폰트로 렌더링한다. 그리고 3초 안으로 폰트가 로딩된다면 해당 웹 폰트로 전환하고, 그렇지 않다면 폴백 폰트를 계속 사용한다.
        - optional : fallback과 매우 유사하다. 100ms 간 텍스트가 보이지 않고, 폴백 폰트로 렌더링한다는 점은 동일하다. 그러나 0.1초 이내로 폰트가 다운로드돼 있거나 캐시돼 있지 않다면 폴백 폰트를 사용한다. (또, 네트워크 상태를 파악해 일정 기간 폰트를 다운로드 하지 못하면 연결을 취소한다.)

요약하자면 최대한 중요한 폰트의 다운로드를 우선순위에 밀어넣고, 이 우선순위를 활용했음에도 빠르게 로딩하는데 실패했다면 다음을 기약하고 기본 폰트를 노출하는 방식이 가장 좋다. 

#### 적절한 이미지 크기 설정

반응형 웹사이트란 사용자 기기의 크기에 따라 자연스럽게 콘텐츠를 노출할 수 있도록 다양한 요소의 콘텐츠를 기기에 의존하게 만든 웹사이트를 말한다. 

```html
img {
	width : 100%;
	height : auto;
}
```

위 코드는 img 태그의 이미지 크기에 맞게 height를 알아서 설정해준다. 하지만 이는 누적 레이아웃 이동이 커지는 결과를 낳을 수 있다.  이 문제를 해결하는 방법은 대체적으로 두 가지다.

- width, height 지정
    - 가장 좋은 방법이다. 위의 CSS와 함께 width, height를 원하는 비율로 지정하면 브라우저가 이미지를 로딩하기 전에 적절한 라고세로 비율을 계산해 이미지가 표시되는 만큼 면적을 할당해 둔다.
    - 이는 `aspect-ratio` 속성 덕분이다. 이 속성은 브라우저의 유저 에이전트 스타일시트(브라우저가 기본으로 제공하는 스타일)에 포함돼있어, 이미지의 가로세로 비율을 자동으로 맞추는 역할을 한다.
    
    ```html
    <img src="/image.jpg" alt="이미지" width="1600" height="900" />
    
    // aspect-ratio를 지원하는 브라우저라면 width="16" height="9" 이렇게 넣어도 동일하게
    작동
    ```
    
- srcset 속성 사용
    - 사용의 뷰포트 너비에 맞추고 싶다면 srcset 속성을 사용하는 것이 좋다.
    - 가로세로 비율이 똑같은, 그러나 크기가 다른 여러 개의 이미지를 준비해 둔 다음 브라우저가 상황에 맞게 이미지를 사용할 수 있도록 준비하면 된다.
    
    ```html
    <img
    	width = "1000"
    	height = "1000"
    	src = "image-1000.jpg"
    	srcset = "image-1000.jpg 1000w, image-2000.jpg 2000w, image-3000.jpg 3000w"
    	alt = ""
    />
    ```
    

## 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들

### 최초 바이트까지의 시간 (Time To First Byte, TTFB)

브라우저가 웹페이지의 첫 번째 바이트를 수신하는데 걸리는 시간을 의미한다. 즉, 페이지를 요청했을 때 요청이 완전히 완료되는 시간이 아니라, 최초의 응답이 오는 바이트까지가 얼마나 걸리는지를 측정하는 지표다. 

- 이 지표는 600ms 이상 걸릴 경우 개선이 필요한 것으로 간주된다.
- 이는 특시 서버 사이드 렌더링을 하고 있는 앱에서 주의 깊게 봐야 할 지표다. 대체로 서버 사이드 렌더링은 최초 페이지를 만들기 위해 서버에서 어느 정도 작업을 수행해야 하기 때문이다.

### 최대 콘텐츠풀 페인트(First Contentful Paint, FCP)

페이지가 로드되기 시작한 시점부터 페이지 콘텐츠의 일부가 화면에 렌더링될 때까지의 시간을 측정한다. 조금 더 쉽게는, **웹사이트에 접속한 순간부터 페이지에 뭐라도 뜨기 시작한 시점까지의 시간을 의미**한다.

일반적으로 최초 콘텐츠풀 페인트는 1.8초 이내에 이뤄지면 좋음, 3.0초는 보통, 그 이후는 개선이 필요한 것을 보고된다.