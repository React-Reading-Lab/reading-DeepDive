# 12 모든 웹 개발자가 관심을 가져야 할 핵심 웹 지표

## 12.1 웹사이트와 성능

사용자가 웹 사이트에 접속했을 때 공통적으로 기대하는 사항

1. 웹사이트를 방문한 목적을 손쉽게 달성
2. 목적을 달성하는데 걸리는 시간이 짧아야 함
3. 개인정보가 노출되는 등의 사고 없이 보안이 철저해야 한다.

웹사이트의 성능은 다음과 같은 요소에 영향을 미친다.

- 1초 내로 로딩되는 사이트는 5초 내로 로딩되는 사이트보다 전자상거래 전환율이 2.5배 높다.
- 0 ~ 5초의 범위에서 1초 로딩이 늦어질수록 전환율은 4.42%씩 떨어진다. 즉, 5초 이상 느려지면 전환율은 20% 가까이 떨어진다.
- 페이지 로드 시간이 0 ~ 2초 사이인 페이지에서 가장 높은 전환율을 달성할 수 있다.

그리고 사용자 또한 이러한 성능에 매우 민감한 것으로 밝혀졌다.

- 소비자의 70%는 페이지 속도가 온라인 커머스 사이트를 방문하는 데 영향을 미친다고 밝혔으며
- 절반 가까운 사람이 더욱 빠르게 로딩할 수 있다면 애니메이션과 동영상이 필요 없다고 밝혔다.

세계 최대의 검색엔진이자 가장 많은 방문객을 보유한 웹사이트를 우녕하는 구글에서도 이와 비슷하게 웹 사이트의 성능에 관한 통계를 내놓은 바 있다.

- 전체 웹페이지를 표시하는 데 필요한 최적의 평균 리소스 요청 수는 50회 미만이다
- 평균적으로 웹 페이지 전체를 요청하는 데 15.3초가 걸린다.
- 인간의 뇌와 신경계를 분석한 결과 페이지 로드 시간이 1초에서 10초로 늘어날수록 모바일 사이트를 이탈할 확률이 123% 증가한다.

개발자들이 이러한 성능에 대해 크게 관심을 기울이지 않는 것이 사실이다.

그 이유로는 첫번째로 개발자들이 사용하는 기기의 성능이 평균적인 유저의 기기보다 좋은 성능과 좋은 네트워크 환경에서 사용하기 때문이다.

두번쨰로는 성능을 개선하는 작업은 새로운 기능을 개발하는 것보다 쉽지도, 재미있지도 않고, 서비스를 개발하는 작업 대비 눈에 띄는 성능 향상을 기대하기도 어렵다는 점이다.

## 12.2 핵심 웹 지표란?

핵심 웹 지표란 구글에서 만든 지표로 웹사이트에서 뛰어난 사용자 경험을 제공하는 데 필수적인 지표를 일컫는 용어이다.

구글에서 핵심 웹 지표로 꼽는 지표는 다음과 같다.

- 최대 컨텐츠풀 페인트( LCP: Largest Contentful Paint )
- 최초 입력 지연( FID: First Input Delay )
- 누적 레이아웃 이동( CLS: Cumulative Layout Shift )

그리고 다음 두 지표는 핵심까지는 아니지만 특정 문제를 진단하는 데 사용될 수 있다고 언급했다.

- 최초 바이트까지의 시간(TTFB: Time To First Byte)
- 최초 콘텐츠풀 시간(FCP: First Contentful Paint)

## 12.3 최대 컨텐츠풀 페인트 (LCP)

### 12.3.1 정의

LCP란 페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간을 말한다.

뷰포트: 사용자에게 혀재 노출되는 화면을 의미

뷰포트 내부에서 '큰 이미지와 텍스트'는 다음과 같이 정의돼 있다.

- <img>
- <svg> 내부의 <image>
- poster 속성을 사용하는 <video>
- url()을 통해 불러온 배경 이미지가 있는 요소
- 텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소
  - 이 블록 레벨 요소에는 <p>, <div> 등이 포함된다.

이미지와 텍스트가 각각 사용자의 시점에 언제 노출됐는지를 확인하는 정확한 시점은 W3C 문서에 나와 있다. 각 엘리먼트가 등장한 시점부터 텍스트 또는 이미지가 완전히 로딩되는 시점으로 보면 된다.

즉. LCP는 사용자의 기기가 노출하느 뷰포트 내부에서 가장 큰 영역을 차지하는 요소가 렌더링되는 데 얼마나 걸리는지를 측정하는 지표인 것이다.

LCP에 영항을 미치는 부분은 오직 뷰포트 영역 뿐이다.

### 12.3.1 의미

만약 어떤 개발자가 '웹페이지가 로딩이 완료되어 사용자에게 노출되기까지 걸리는 시간'을 물어보면 무엇을 기준으로 측정하면 될까?

가장 먼저 떠오르는 것은 DOMContentLoaded 이벤트가 호출되는 시간일 것이다. DOMContentLoaded는 HTML 문서를 완전히 불러오고 파싱했을 때 발생하는 이벤트로 페이지의 document를 대상으로 일어나며 단 한 번만 호출된다.

그러나 DOMContentLoaded 이벤트는 스타일시트, 이미지, 하위 프레임의 로딩은 기다리지 않는다.

그렇다면 사용자가 페이지가 어느 정도 로딩됐다고 인식하는 시점은 언제일까?

사용자가에게 있어 로딩이란 일단 뷰포트 영역에 보이는 부분을 기준으로 할 것이므로 뷰포트에 메인 컨텐츠가 화면에 완전히 전달되는 속도를 기준으로 한다면 사용자는 페이지가 로딩이 완료됐다고 체감하는 시간과 매우 비슷하게 측정할 수 있을 것이다.

### 12.3.4 기준 점수

LCP 등의 각종 지표 점수를 측정하는 방법으로는 먼저 직접 자바스크립트 API를 호출하는 방법과 다른 도구를 활용하는 방법이 있는데, 손쉬운 측정을 위해서는 대부분 후자를 택한다.

LCP에서 좋은 점수란 해당 지표가 2.5초 내로 응답이 오는 것이다. 4초 이내는 보통 그 이상은 나쁨으로 판단된다.

### 12.3.5 개선 방안

점수를 높일 수 있는 방법을 알아보자

#### 텍스트는 언제나 옳다.

가장 확실한 방법은 뷰포트 최대 영역, 즉 LCP 예상 영역에 이미지가 아닌 문자열을 넣는 것이다. 제아무리 이미지 최적화를 한다고 해도 추가적인 로드가 필요한 이미지보다 텍스트 노출이 훨씬 빠르다.

#### 이미지는 어떻게 불러올 것인가?

개발자가 선택할 수 있는 이미지를 노출하는 방법에는 다음과 같이 여러가지가 있다.

```
<img src="" >

<svg xmlns="">
  <image href="" >
</svg>

<video poster=""></video>

<div style="background-imaage: url()">
```

총 4가지 방법이 존재하는데 각각을 사용했을 때 이미지 로딩 속도에 어떠한 차이가 있는지 살펴보자

1번과 3번의 코드가 더 빠른 로드 속도를 가진다.

- <img> : 이미지는 브라우저의 프리로드 스캐너에 의해서 먼저 발견되어 빠르게 요청이 일어난다. 프리로드 스캐너란 HTML을 파싱하는 단계를 차단하지 않고 이미지와 같이 빠르게 미리 로딩되면 좋은 리소스를 먼저 찾아 로딩하는 브라우저의 기능이다.

- <svg> 내부의 <img> : 테스트 결과를 잘 보면 한 가지 흥미로운 결과를 볼 수 있는데 <img>가 미처 로드되지 않은 시점, <img>와는 다른 점이 바로 모든 리소스를 불러온 이후에 이미지를 불러온다는 점이다. 즉, <svg> 내부의 이미지는 프리로드 스캐너에 의해 발견되지 않아 병렬적으로 다운로드가 일어나지 않는다.

- <video>의 poster: poster는 사용자가 video 요소를 재생하거나 탐색하기 전까지 노출되는 요소다. 이 역시 마찬가지로 프리로드 스캐너에 의해 조기에 발견되어 <img>와 같은 성능을 나타낸다.

- background-image: CSS에 있는 리소느는 항상 느리다. 이러한 리소느는 브라우저가 해당 리소스를 필요로 하는 DOM을 그릴 준비가 될 때까지 리소스 요청을 뒤로 미루기 때문이다. 즉 LCP에 안 좋은 영향을 끼칠 가능성이 크다.

#### 그 밖에 조심해야 할 사항

- 이미지 무손실 압축: 당연한 이야기지만 웹으로 서비스할 이미지는 가능한 한 무손실 형식으로 압축해 최소한의 용량으로 서비스 하는 것이 좋다.

- loading=lazy 주의: `loading=lazy`는 리소를 중요하지 않음으로 표시하고 필요할 때만 로드하는 전략. 즉 LCP에 좋을 순 있지만 LCP로 표시되는 이미지는 중요한 컨텐츠이므로 사용하지 않는 것이 좋다.

- fadein과 같은 애니메이션: 당연하게도 이미지가 그냥 뜨는 것보다 애니메이션 효과를 처리하면 LCP도 늦어진다.

- 클라이언트에서 빌드하지 말 것: 앞선 연구 사례에서 볼 수 있는 최적의 시나리오는 무엇일까? 서버에서 빌드해온 HTML을 프리로드 스캐너가 바로 읽어서 최대 커넨츠풀 페인트로 가져가는 것이다.

만약 useEffect에서 API 페칭을 통해 데이터를 표시한다면 클라이언트 단에서 실행되는 것이기 떄문에 LCP 성능은 나빠질 것이다.

- LCP 리소스는 직접 호스팅: LCP는 같은 도메인에서 직접 호스팅이 하는 것이 좋다. 일반적으로 이미지르 ㄹ다른 출처에서 가져오면 최적화에 별로 좋은 영향을 미치지 못한다.

## 12.4 최초 입력 지연(FID)

### 12.4.1 정의

웹페이지의 로딩 속도만큼 중요한 것이 웹사이트의 반응 속도 이다. 그리고 이러한 웹사이트의 반응성을 측정하는 지표가 FID이다.

### 12.4.2 의미

웹 사이트 내부의 이벤트가 반응이 늦어지는 이유는 무엇일까? 그 이유는 대부분 해당 입력을 처리해야 하는 브라우저의 메인 스레드가 바쁘기 때문이다.

그렇다면 메인 스레드가 바쁜 이유는 무엇일까? 무언가 대규모 렌더링이 일어나고 있거나 대규모 자바스크립트 파일을 분석하고 실행하는 등 다른 작업을 처리하는 데 리소스를 할애하고 있기 때문이다.

이렇게 메인 스레드가 바쁜 경우 자바스크립트 실행 환경은 '싱글 스레드'이기 때문에 자바스크립트가 이벤트 리스너와 같은 다른 작업을 실행할 수 없어 지연이 발생한다.

구글은 사용자 경험을 크게 4가지로 분류해 정의하는데 이를 RAIL이라고 한다.

- Response: 사용자의 입력에 대한 반응 속도. 50ms 미만으로 이벤트를 처리할 것
- Animation: 애니메이션의 각 프레임을 10ms 이하로 생성할 것
- Idle: 유휴 시간을 극대화해 페이지가 50ms 이내에 사용자 입력에 응답하도록 할 것
- Load: 5초 이내에 컨텐츠를 전달하고 인터랙션을 준비할 것

### 12.4.4 기준 점수

최초 입력 지연의 좋은 점수를 얻기 위해서는 100ms 이내로 응답이 와야하며 300ms 이내인 경우 보통 그 이후에는 나쁨으로 처리된다.

### 12.4.5 개선 방안

#### 실행에 오래 걸리는 긴 작업을 분리

long task가 있다면 몇 가지 대안을 연구해야 한다.

- 꼭 웹 페이지에서 해야하는 작업인가: 만약 개발자의 최신 개발 기기에서도 오랜 시간이 소요되는 작업이라면 실제 사용자가 이용하는 경우에는 더욱 오래 걸릴 것인다. 웬만하면 서버로 옮겨서 처리하는 것이 좋다. 서버에서 처리하면 상대적으로 빠르고 쾌적한 환경에서 처리해 브라우저의 메인 스레드를 오래 점유하지 않게 할 수 있다.

- 긴 작업을 여러 개로 분리하기: 만약 꼭 웹페이지를 처리해야 하는 작업이라면 해당 작업을 여러 개로 분리하는 것이 좋다. 이러한 리소스는 리액트의 Suspense의 lazy를 혹은 Nextjs의 Dynamic을 이용해 나중에 불러오게 할 수 있다.

#### 자바스크립트 코드 최소화

현대의 번들링 도구들은 코드 번들링에 필요한 코드만 모아서 최종 프로덕션 코드를 생성한다.

하지만 여전히 필요없는 코드가 존재할 수 있다.이러한 코드를 크롬 개발자 도구를 통해 확인할 수 있다.

`커버리지`를 클릭하고 `기록` 버튼을 클릭해 새로고침하면 커버리지가 기록된다.

사용되지 않는 코드들은 모두 삭제해야하는 것은 아니지만 우선순위를 낮춰서 불러오는 것이 좋다.

또 한가지 살펴볼만한 점은 polyfill이다. 폴리필이란 브라우저에서 지원하지 않는 기능을 사용하기 위해 웹페이지에서 직접 구현하고 집어 넣는 코드를 말한다.

예를 들어 Array.prototype.find 메서드는 익스플로러 11 이하 버전에서는 지원하지 않는다.

이러한 메서드를 사용하기 위해서는 웹페이지에서 다음과 같은 폴리필이 필요하다.

```
Object.defineProperty(Array.prototype, 'find', {
  enumerable: false,
  configurable: true,
  writable: true,
  value: function(predicate) {
    ...
  }
})
```

하지만 폴리필의 크기는 상당히 크다. 따라서 폴리필을 넣기 전에 두 가지 사항을 먼저 체크해봐야 한다.

1. 폴리필이 필요한 환경인가?

2. 꼭 필요한 폴리필인가?

#### 타사 자바스크립트 코드 실행의 지연

개발자가 구축한 어플리케이션에 꼭 개발자가 만든 스크립트만 들어가라는 법은 없다. 이러한 타사 스크립트는 대부분의 웹페이지 로드에서 중요한 자원이 아니므로 async나 defer를 이요해 지연 불러오기를 하는 것이 좋다.

- async: script에 async 속성이 있으면 해당 스크립트를 다른 리소스와 병렬로 다운로드한다. async 리소르의 다운로드가 완료되면 다른 리소스의 다운로드는 기다리지 않고 바로 실행한다.

- defer: script를 다른 리소스오 함께 병렬로 다운로드한다. 다운로드하는 중에도 HTML 파싱 등의메인 스레드 작업은 멈추지 않는다. 다운로드가 완료되었더라도 이 스크립트의 실행은 페이지가 완전히 로딩된 이후에 맨 마직막에 실행된다.

- 둘 다 없는 경우: script를 만나는 순간 다운로드가 우선되며 다운로드가 완료되면 코드 실행이 우선된다. 다른 작업은 다운로드와 실행이 끝날 때까지 미뤄진다.

만약 광고와 같이 실제 사용자의 뷰포트 윛에 따라 불러와야 하는 컴포넌트라면 Intersection Observer를 이용해 뷰포트에 들어오는 시점에 불러오는 것이 좋다.

## 12.5 누적 레이아웃 이동(CLS)

### 12.5.1 정의

혹시 웹사이트에서 로딩이 끝난 줄 알고 무언가를 클릭하려 했는데 그 사이 다른 요소가 로딩되면서 원래 클릭하려고 했던 요소를 클릭하지 못해서 당황했던 경험이 있는가?

이처럼 페이지의 생명주기 동안 발생하는 모든 예기치 않은 이동에 대한 지표를 계산하는 것이 바로 누적 레이아웃 이동이다.

### 12.5.2 의미

최초 렌더링 이후에 실행되는 useEffect가 많을수록 그리고 이 useEffect가 렌더링에 영향을 미칠수록 이 누적 레이아웃 이동에서 좋은 점수를 받지 못할 것이다.

해당 점수를 계산할 때 포함되는 내용은 다음과 같다.

- 영향분율: 레이아웃 이동이 발생한 요소의 전체 높이와 뷰포트 높이의 비율을 의미한다.

- 거리분율: 레이아웃 이동이 발생한 요소가 뷰포트 대비 얼마나 이동했는지를 의미한다. 예를 들어 예기치 않은 레이아웃 이동으로 인해 10만큼 내려갔고, 전체 뷰포트가 100이라면 0.1점이 된다.

### 12.5.4 기준 점수

누적 레이아웃 이동의 경우 0.1 이하인 경우 좋음. 0.25 이하인 경우 보통이며 그 외에는 개선이 필요함

### 12.5.5 개선 방안

#### 삽입이 예상되는 요소를 위한 추가적인 공간 확보

대부분의 큰 누적 레이아웃 이동은 클라이언트에서 삽입되는 동적인 요소로 인해 발생한다. 여기에는 동적으로 요소가 삽입되는 것 외에도 갑자기 요소의 크기가 바뀌거나 뒤늦게 광고와 같은 타사 라이브러리가 브라우저에서 로드되는 등의 작업 때문에 나타난다.

이러한 영향을 방지하기 위해 useEffect의 사용을 최소화하는 것이 좋다. 불가피하다면 useLayoutEffect 훅을 사용해 보는 것 또한 검토해 볼 만 하다. 하지만 useLayoutEffect는 동기적으로 발생해 브라우저의 페인팅 작업에 영향을 미치기 때문에 사용자에게 로딩이 오래 걸리는 것 처럼 보일 수 있다.

#### 폰트 로딩 최적화

누적 레이아웃 이동과 폰트 간에 큰 관계가 없다고 생각할 수 있지만 폰트 또한 레이아웃 이동을 일으키는 원인 중 하나다.

폰트로 인해 발생할 수 있는 문제점은 크게 2가지이다.

1. FOUT(flash of unstyled text): HTML 문서에서 지정한 폰트가 보이지 않고 대체 기본 폰트로 보이고 있다가 뒤늦게 적용되는 현상

2. FOIT(flash of invisible text): HTML 문서에서 지정한 폰트가 보이지 않고 기본 폰트도 없어서 텍스트가 없는채로 있다가 뒤늦게 폰트가 로딩되면서 페이지에 렌더링되는 현상

폰트는 각각 고유의 높이와 너비를 가지고 있다. 즉 FOUT FOIT 현상이 발생하면서 레이아웃 이동이 발생할 수 있다.

- <link>의 preload 사용: <link> 요소의 rel=preload는 페이지에서 즉시 필요로 하는 리소스를 명시하는 기능이다. preload로 지정된 요소는 웹페이지의 생명주기에서 초기에 불러와야 하는 중요한 리소스로 간주되어 브라우저는 리소스를 빠르게 가져올 수 있도록 준비한다.

- font-family: optional: 폰트를 불러올 수 있는 방법은 크게 다섯 개로 나뉜다.
  - auto(기본값) : 브라우저가 폰트를 불러오는 방법을 결정한다.
  - block: 폰트가 로딩되기 전까지 렌더링을 중단한다. (최대 3초) 웹 폰트의 로딩이 완료되면 비로소 폰트를 적용한다.
  - swap: 앞서 언급한 FOUT 방식이다. 우선 폴백 폰트로 글자를 렌더링한 다음 웹 폰트의 로딩이 완료되면 웹 폰트를 적용한다.
  - fallback: 이 옵션을 사용하면 100ms간 텍스트가 보이지 않고 그 이후 폴백 폰트로 렌더링한다. 그리고 3초 안에 폰트가 로드되면 대체하고 아니면 폴백 폰트를 그대로 사용한다.
  - optional: fallback과 매우 유사하다. 100ms 간 텍스트가 보이지 않고, 폴백 폰트로 렌더링한다는 점은 동일하다. 그러나 0.1초 이내로 폰트가 다운로드돼 있거나 캐시돼 있지 않다면 폴백 폰트를 사용한다. 브라우저가 네트워크 상태를 파악해 일정 기간 폰트를 다운로드하지 못한다면 연결을 취소한다. 즉 0.1초 내로 폰트가 다운로드되지 않으면 해당 폰트를 보여주지 않고, 이후에 해당 폰트 리소르르 사용할 때를 고려해 폰트를 다운로드하긴 하나 이마저도 네트워크 환경에 따라 취소될 수 있다.

#### 적절한 이미지 크기 설정

```
img {
  width: 100%
  heigth: auto
}
```

뷰포트 너비에 따라 이미지의 크기를 결정하는 코드이다.

하지만 이는 누적 레이아웃 이동이 커지는 결과를 낳는다. 높이는 이미지가 완전히 로드되기 전에는 알 수 없기 떄문에 로드 이후 계산하여 적용한다. 이로인해 레이아웃 이동이 크게 발생할 수 있다.

- width, height 지정: width와 heigth를 지정하는 것이 가장 좋은 방법이다.

- 만약 사용자 뷰포트 너비에 맞춰 다른 이미지를 제공하는 경우 즉 반응형 이미지를 사용하고 싶다면 srcset 속성을 사용하는 것이 좋다. 가로세로 비율이 똑같은, 그러나 크기가 다른 여러 개의 이미지를 미리 준비해 둔 다음 브라우저가 상황에 맞게 이미지를 사용할 수 있도록 준비하면 된다.

```
<img
  width="1000"
  heigth="1000"
  src=""
  srcset="image-1 1000w, image-2 2000w, image-3 3000w"
  />
```

### 12.5.6 핵심 웹 지표는 아니지만 성능 확인에 중요한 지표들

#### 최초 바이트까지의 시간(Time To First Byte. TTFB)

브라우저가 웹페이지의 첫 번째 바이트를 수신하는데 걸리는 시간을 의미한다. 즉 페이지를 요청했을 때 요청이 완전히 완료되는 데 걸리는 시간을 측정하는 것이 아니라 최초의 응답이 오는 바이트까지 얼마나 걸리는지를 측정하는 지표다. 해당 지표는 600ms 이상 걸릴 경우 개선이 필요한 것으로 간주된다.

특히 서버사이드 렌더링을 하는 경우 주의 깊게 봐야할 지표이다.

- 서버 사이드 렌더링을 수행하고 있다면

  - 로직을 최적화해 페이지를 최대한 빨리 준비시켜야 한다.

  - 서버 사이드 렌더링 시에 API 호출이 필요하다면 이 API 호출 또한 최적화할 필요가 있다. 호출 횟수와 가져오는 정보의 크기를 최소화해서 최대한 응답의 속도를 빠르게 하는 것이 중요하다.

- 웹페이지의 주된 방문객이 국적을 파악해 최대한 해당 국적과 가깝게 서버를 위치시키는 것이 중요하다.

- 리액트 서버 사이드 렌더링이라면 renderToNodeStream, renderToStaticNodeStream과 같은 스트리밍 API를 사용하는 것이 좋다.

#### 최초 컨텐츠풀 페인트(FCP)

페이지가 로드되기 시작한 시점부터 페이지 컨텐츠의 일부가 화면에 렌더링될 때까지의 시간을 측정한다.

FCP는 1.8초 이내에 이뤄진다면 좋음. 3초 이내는 보통 그 이상은 나쁨이다.

FPC를 개선하려면 다음 사항을 고려해야 한다.

- TTFB 개선
- 렌더링을 가로막는 리소스 최소화: 자바스크립트나 CSS 같은 렌더링을 가로막는 리소를 최소화하고 렌더링을 방해하는 리소를 비동기적으로 로드하도록 해야 한다.
- Above the Fold에 대한 최적화: 웹에서 최초 스크롤을 굳이 하지 않아도 보이는 영역을 Above the fold라고 한다. 해당 영역은 빠르게 무언가를 보여줘야 하는 영역이므로 게으른 로딩이나 스크립트에 의존하는 것은 모두 도움이 되지 않는다.
- 페이지 리다이렉트 최소화
- DOM 크기 최소화
