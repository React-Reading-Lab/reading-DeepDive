- 책 내용 정리만 수행

# 프로세스의 개념

## 운영체제

프로세스를 읽고 실행하여 프로그램에 생명을 불어넣는 주체.

## 프로세스

실행 중인 프로그램. 디스크 상에 존재하며 실행을 위한 명령어와 정적 데이터의 묶음.

프로세스를 간단하게 표현하려면, 실행되는 동안 접근했거나 영향을 받은 자원의 목록을 작성하면 된다.

### 시스템 콜

프로세스가 운영체제에게 서비스를 요청하는 인터페이스다.

프로세스가 직접 하드웨어를 다룰 수 없으므로, 운영체제에 특정 기능을 요청해야 한다. 운영체제는 시스템 콜 형태로 하드웨어를 제어할 수 있는 다양한 방법을 추상화하여 제공하고 있다.

보통 C언어로 구현된 저수준 함수 형태.

### 하드웨어 상태(machine state)

프로그램이 실행되는 동안 하드웨어 상태를 읽거나 갱신할 수 있다.

- 메모리(주소 공간) : 프로세스 하드웨어 상태 중 가장 중요한 구성 요소.
  - 명령어는 메모리에 저장됨. 프로세스가 읽고 쓰는 데이터 역시 메모리에 저장됨.
- 레지스터 : 프로세스 하드웨어 상태 중 하나. 많은 명령어들이 레지스터를 직접 읽거나 갱신.
  - 프로그램 카운터 (명령어 포인터) : 프로그램의 어느 명령어가 실행 중인지를 알려줌
  - 스택 포인터 & 프레임 포인터 : 함수의 변수와 리턴 주소를 저장하는 스택을 관리할 때 사용하는 레지스터.

## 가상화

컴퓨터들은 동시에 수십 혹은 수백 개의 프로세스를 실행하는 것처럼 보인다. 하지만 실제로 컴퓨터에 내장된 CPU의 개수는 한정돼있다.

운영체제는 **가상화**를 사용하여 이러한 환상을 만들어낸다.

CPU 가상화를 구현하기 위해서는 **저수준 도구**와 고차원적인 **지능** 이 필요하다.

### 매커니즘 (저수준 도구)

필요한 기능을 구현하는 방법이나 규칙을 의미한다.

매커니즘의 한 예 : 시분할

### 시분할

운영체제는 하나의 프로세스를 실행하고, 얼마 후 중단시키고 다른 프로세스를 실행하는 작업을 반복하면서 여러개의 가상 CPU가 존재하는 듯한 환상을 만든다.

**시분할 기법은**, 원하는 수 만큼의 프로세스를 동시에 실행할 수 있게 한다. 모든 현대 운영체제들이 채택하고 있다.

- 대응되는 개념 : 공간 분할
  - 개체에게 공간을 분할함. 예를 들어 디스크는 공간을 분할할 수 있는 자원이다. 블럭이 하나의 파일에 할당되면 파일을 삭제하기 전에는 다른 파일이 할당될 가능성이 낮다.

### 정책 (지능)

운영체제의 지능은 정책(Policy)의 형태로 표현된다. 정책은 운영체제 내에서 어떤 결정을 내리기 위한 알고리즘이다.

- 예) 스케쥴링 정책 : 실행 가능한 여러 프로그램들이 있을 때, 어떤 프로그램부터 실행시켜야 하는가?

# 프로세스 API

운영체제가 제공하는 API 중에서 프로세스 생성, 종료, 제어와 관련된 것만 가리킨다.

API로 반드시 제공해야하는 기본 기능이다.

- 생성 : 새로운 프로세스를 생성할 수 있는 방법을 제공해야 한다.
- 제거 : 프로세스를 강제로 제거할 수 있는 인터페이스를 제공해야 한다.
- 대기 : 어떤 프로세스의 실행 중지를 기다릴 필요가 있기 때문에, 여러 종류의 대기 인터페이스를 제공해야 한다.
- 각종 제어 : 제거, 대기 이외에 여러 가지 제어 기능들이 제공된다. (일시정지, 재시작 등)
- 상태 : 프로세스 상태 정보를 얻어내는 인터페이스다. 얼마 동안 실행되었는지, 프로세스가 어떤 상태에 있는지 등

### 프로세스 생성 (프로그램 준비 및 생성, 실행)

1. 프로그램 코드와 정적 데이터를 메모리, 주소공간에 탑재(load)
   - 탑재 : 디스크 상의 프로그램을 찾아 프로세스의 주소 공간으로 읽어들인다.
   - 프로그램은 디스크(or SSD)에 **특정 실행 파일 형식**으로 존재한다.
   - 디스크의 실행 파일 바이트를 읽어서 메모리 어딘가에 저장한다.
   - 초기 운영체제들은 프로그램 실행 전에 코드와 데이터를 모두 메모리에 탑재하였으나 현대 운영체제는 해당 작업을 늦춤.
     - 프로그램을 실행하면서 코드나 데이터가 필요할 때 필요한 부분만 메모리에 탑재하는 방식으로.
2. 일정량의 메모리를 프로그램의 **실행시간 스택** 용도로 할당
   - C프로그램은 지역 변수, 함수 인자, 리턴 주소 등을 저장하기 위해 스택을 사용한다. 운영체제는 이 스택을 주어진 인자로 초기화한다.
   - main 함수의 인자인 argc와 argv 벡터.
3. 프로그램의 힙(heap)을 위한 메모리 영역을 할당한다.
   - malloc으로 필요한 공간을 요청, free로 사용하던 공간 반환.
   - 힙은 연결 리스트, 해시 테이블, 트리 등 **크기가 가변적인 자료 구조**를 위해 사용됨.
4. 입출력과 관계된 초기화 작업 수행
   - 예) Unix 속 세 개의 파일 디스크립터 초기화
5. 프로그램 실행을 위한 준비를 마쳤으므로, 운영체제는 CPU를 새로 생성된 프로세스에 넘기고 프로그램 실행.

### 프로세스 상태

프로세스 상태는 다음 세 상태중 하나로 존재할 수 있다.

- 실행 : 실행 상태에서 프로세스는 프로세서에서 실행 중이다.
- 준비 : 준비 상태에서 프로세스는 실행할 준비가 되어 있지만 운영체제가 다른 프로세스를 실행하고 있는 등의 이유로 대기 중이다.
- 대기 : 프로세스가 다른 사건을 기다리는 동안 프로세스의 수행이 중단된 상태.

프로세스는 운영체제의 **스케줄링 정책**에 따라 **스케줄**이 되면 준비 상태에서 실행 상태로 전이.

![image.png](attachment:235ee1b4-adb5-4edc-b7a3-0cbb4e694e92:image.png)

운영체제는 **스케쥴러**를 통해 프로세스의 상태 간 이동을 결정한다.

### 프로세스 제어 블럭 (PCB)

**프로세스 리스트**는 시스템에서 실행 중인 프로그램을 관리하기 위한 운영 체제의 자료 구조다.

프로세스 관리를 위한 정보를 저장하는 자료 구조를 프로세스 제어 블럭(PCB)라 부른다. 각 프로세스에 관한 정보를 저장하는 C 자료 구조를 이야기 할 때 부르는 이름이다.

## 자료 구조

운영체제는 다양한 정보를 유지하기 위한 자료 구조를 많이 가지고 있다.

- 레지스터 문맥 자료구조 : 프로세스가 중단되었을 때 해당 프로세스의 레지스터 값들을 저장. 이 레지스터 값들을 복원하여 운영체제는 프로세스 실행을 재개.

# 프로세스 API - 더 자세히

프로세스를 생성하고 제어하려면 운영체제는 그에 따른 인터페이스를 제공해야 한다.

Unix는 프로세스를 생성하기 위해 fork()와 exec() 시스템 콜을 사용한다.

wait()은 프로세스가 자신이 생성한 프로세스가 종료되기를 기다리기 원할 때 사용한다.

### fork() 시스템 콜

프로세스 생성에 사용된다.

C 프로그램에서 fork()를 사용하여 프로세스를 생성할 시, 해당 프로세스는 fork를 호출한 프로세스의 자식 프로세스가 되며, 부모 프로세스를 복사하여 만들어진다.

하지만 자식 프로세스는 main부터 시작되지 않는다. 호출된 라인부터 실행되며, 부모 프로세스와 다른 프로세스ID를 같는 별도의 프로세스이다.

이후 printf 문이 있다면, 해당 라인을 부모 프로세스가 먼저 실행할 지, 자식 프로세스가 먼저 실행할 지는 아무도 모른다.

CPU 스케쥴러는 실행할 프로세스를 선택하지만 일반적으로 그 동작이 상당히 복잡하고 상황에 따라 다른 선택이 이루어지기 때문에, **어느 프로세스가 먼저 실행된다고 단정짓기 어렵다**.

이 **비결정성(nondeterminism)으로** 인해 **멀티 스레드 프로그램** 실행 시 다양한 문제가 발생한다.

### wait() 시스템 콜

부모 프로세스가 자식 프로세스의 종료를 대기해야 하는 경우도 발생할 수 있다. wait() 시스템 콜이 그 역할을 한다.

자식 프로세스가 종료되면 wait()는 리턴한다.

이 케이스에서는 자식 프로세스가 항상 부모 프로세스보다 먼저 출력을 수행한다.

### exec() 시스템 콜

자기 자신이 아닌 다른 프로그램을 실행해야 할 때 사용하는 시스템 콜이다.

fork() 시스템 콜은 자기 자신의 복사본을 생성하여 실행하는 반면, exec()는 아예 다른 프로그램을 실행시킨다.

실행 파일의 이름과 인자가 주어지면 실행 파일의 코드 와 정적 데이터를 읽어 들여 현재 실행 중인 프로세스 코드 세그멘트와 정적 데이터 부분을 덮어 쓴다. 힙과 스택 및 프로그램 다른 주소 공간들로 새로운 프로그램의 실행을 위해 다시 초기화된다.

즉, 새로운 프로세스를 생성하는게 아니라, **현재 실행 중인 프로그램을 다른 실행 중인 프로그램으로 대체하는 것**이다.

### fork와 exec. 왜 이런 API를?

쉘은 프롬프트를 표시하고 사용자가 무언가 입력하기를 기다린다.

대부분의 경우 쉘은 파일 시스템에서 실행 파일의 위치를 찾고 명령어를 실행하기 위해 `fork()`를 호출해 새로운 자식 프로세스를 만든다. 그런 후 `exec()` 의 변형 중 하나를 호출하여 프로그램을 실행시킨 후 `wait()` 를 호출하여 명령어가 끝나기를 기다린다.

자식 프로세스가 종료되면 쉘은 `wait()` 으로부터 리턴하고 다시 프롬프트를 출력하고 다음 명령을 기다린다.

이런 식으로, fork()와 exec()를 분리하여 쉘은 많은 유용한 일은 더 쉽게 할 수 있다.

- ex) 출력 위치를 .txt 파일로 변경하고 싶은 경우, exec()가 호출되기 전에 표준 출력 파일을 닫고 txt 파일을 열면 된다.

```c
// 그림 8.4. 입출력 재지정의 모든 것(p4.c)

1 #include <stdio.h>
2 #include <stdlib.h>
3 #include <unistd.h>
4 #include <string.h>
5 #include <fcntl.h>
6 #include <sys/wait.h>
7 int main(int argc, char *argv[])
9 {
10 int rc = fork();
11 if (rc < 0) { // fork 실패. exit
12 fprintf(stderr, “fork failed\n ”);
13 exit(1);
14 } else if (rc == 0) { // 자식 : 표준 출력 파일로 재지정
15 close(STDOUT_FILENO);
16 open(“ ./p4.output ”, O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);
17
18 // ᯱ exec“wc ”. . .
19
20
21 char *myargs[3];
22 myargs[0] = strdup(“wc ”); // 프로그램 : "wc" (단어 세는 프로그램)

23 myargs[1] = strdup(“p4.c ”); // 인자 : wc가 단어를 셀 파일
24 myargs[2] = NULL; // 배열의 끝 표시
25 execvp(myargs[0], myargs); // wc 실행
26 } else { // 부모 프로세스는 이 경로를 따라 실행한다. (main)
27 int wc = wait(NULL);
28 }
29 return 0;
```

### 그 외 프로세스

- kill() 시스템 콜 : 프로세스에게 시그널을 보내는 데 사용됨.
  - 시그널은 프로세스를 중단시키고, 삭제하는 등의 작업에 사용된다.
