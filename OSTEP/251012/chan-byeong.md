### 11-1 초기 시스템

운영체제는 메모리에 상주하는 루틴의 집합이었다. 물리 메모리에 하나의 실행 중인 프로그램이 존재하였고 나머지 메모리를 사용하였다.

![image.png](attachment:c1cc1f88-b231-4153-9367-959533ae69a6:image.png)

### 11-2 멀티프로그래밍과 시분할

**멀티프로그래밍**

여러 프로세스가 실행 준비 상태에 있고 운영체제는 그들을 전환하면서 실행.

이런 전환을 통해 **CPU 이용률을 증가**

**시분할**

많은 사람들이 일괄처리방식(batch computing) 컴퓨팅의 한계를 인식.

많은 사용자가 동시에 컴퓨터를 사용하고, 현재 실행 중인 작업으로부터 즉시 응답을 원하기 때문에 대화식 이용의 개념이 중요하게 등장.

시분할 시스템이 대중화되면서 여러 프로그램이 메모리에 동시에 존재하려면 **보호**가 중요한 문제가 된다.

### 11-3 주소 공간

위험에 대비하기 위하여 운영체제는 **사용하기 쉬운 메모리 개념**을 만들어야 한다. 이 개념이 **주소 공간**이다.

주소 공간은 실행 프로그램의 모든 메모리 상태를 갖고 있다.

예를 들어, 프로그램의 코드는 반드시 메모리에 존재해야 한다.

스택은 함수 호출 체인 상의 현재 위치, 지역 변수, 함수 인자와 반환 값 등을 저장하는데 사용.

힙은 동적으로 할당되는 메모리를 위해 사용된다.

주소 공간 구성 요소 - 코드, 스택, 힙

코드 ← 정적이기 때문에 추가 메모리 필요 X, 상단에 배치.

힙, 스택 ← 동적이여서 확장/축소 가능, 그래서 양 끝단으로 배치. (힙은 상단에, 스택은 하단에)

![image.png](attachment:2f2c7d6a-8ca2-40a1-8e89-1502387f0961:image.png)

<aside>
💡

핵심 질문: 메모리를 어떻게 가상화하는가

운영체제는 물리 메모리를 공유하는 다수의 프로세스에게 어떻게 프로세스 전용의 커다란 주소 공간이라는 개념을 제공할 수 있는가?

</aside>

### 11-4 목표

1.  가상 메모리 시스템(VM)의 주요 목표 중 하나는 투명성(transparency)이다.

운영체제는 실행 중인 프로그램이 가상 메모리의 존재를 인지하지 못하도록 가상 메모리 시스템을 구현해야 한다.

1. 효율성(efficiency)

운영체제는 가상화가 시간과 공간 측면에서 효율적이도록 해야 한다. 시간적으로는 프로그램이 너무 느리게 실행되서는 안되고 공간적으로는 가상화를 지원하기 위한 구조를 위해 너무 많은 메모리를 사용해서는 안 된다. 시간-효율적인 가상화를 구현할 때 운영체제는 TLB 등의 하드웨어 지원을 받게 된다.

1. 보호(protection)

운영체제는 프로세스를 다른 프로세스로부터 보호해야 하고 운영체제 자신도 프로세스로부터 보호해야 한다. 프로세스가 자신의 주소 공간 밖에 접근할 수 있어서는 안 된다. 즉 프로세스들을 서로 고립 시켜야 한다.

## 추가 학습

물리 메모리

- 실제 RAM 칩 (프레임 단위로 관리)

가상 메모리

- 각 프로세스가 보는 주소 공간 (프로세스 별 독립적), 하드웨어와 OS가 가상 주소 ↔ 물리 주소 매핑을 관리

0번지 부터 시작, 연속적인 메모리 공간

실제 메모리(RAM)은 페이지 단위로 분리되어 여러 프로세스에 배치된다.

**메모리 레이아웃**

![image.png](attachment:0d1e74c9-aea6-4a27-b092-a894f58992d3:image.png)

Code: 실행 가능한 머신코드, 일반적으로 읽기/실행 권한, 쓰기 불가

DATA: 초기화된 전역/정적 변수

BSS: 초기화되지 않은 전역/정적 변수 (프로그램 시작 시 0으로)

Heap: 런타임 동적 메모리 할당 영역

Stack: 함수의 지역변수, 리턴 주소, 인자 등이 저장됨.

**가상 → 물리 주소 변환**

1. 페이지 - 프레임
   1. 페이지: 가상 메모리의 관리 단위 (4kb)
   2. 프레임: 물리 메모리의 동일한 크기 단위
   3. 페이지 - 프레임으로 1:1 매핑된다.
2. MMU (Memory Management Unit)
   1. CPU 내부 또는 칩셋의 하드웨어 장치
   2. 가상주소가 들어오면 MMU가 페이지 테이블을 참조해 물리주소를 찾음.
   3. 직접적으로 TLB를 사용해 빠른 변환을 먼저 시도
3. 페이지 테이블
   1. 운영체제가 관리하는 **가상 페이지 → 물리 프레임 매핑 저장.**
4. TLB (Translation Lookaside Buffer)
   1. 가상 → 물리 매핑을 캐시하는 작은 고속 메모리 (하드웨어)
   2. 주소 변환은 대부분 TLB 히트로 처리되어 매우 빠름
   3. 페이지 테이블이 수정될 경우 TLB 무효화 필요.
5. 페이지 폴트
   1. MMU가 참조한 페이지 테이블 엔트리가 유효하지 않으면 CPU 인터럽트 발생, 커널로 제어가 넘어간다.
   2. OS가 페이지 폴트를 처리
      1. 페이지 폴트 발생 원인 파악하고, 페이지가 디스크에 있는 경우면 디스크에 있는 데이터를 불러 물리 프레임에 로드한다.

_MMU 내부에 TLB 캐시가 존재한다._
