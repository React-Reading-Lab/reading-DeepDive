- MMU의 상세한 기능 및 하드웨어 구조
- 베이스/바운드 레지스터는 단순한 값인데 왜 레지스터라고 할까?
- 왜 세그먼트 테이블처럼 특정 테이블은 하드웨어의 지원이 필요할까?

이전까지 *프로세스 주소 공간 전체*를 메모리에 탑재하는 것을 가정함.

베이스, 바운드 레지스터를 활용하여 프로세스를 물리 메모리의 다른 부분으로 재배치.

하지만, 스택 - 힙 사이의 메모리 낭비가 심하다. 즉 유연성이 없다.

### 1. 세그멘테이션: 베이스/바운드의 일반화

_MMU_ 안에 하나의 베이스/바운드 쌍이 아니라, 논리적으로 나눈 세그먼트 마다 베이스/바운드 쌍이 존재한다.

![image.png](attachment:28d15fb9-a4f0-4cb8-8aa0-a44d7f4652a1:image.png)

![image.png](attachment:f585bc19-11ca-4c86-9cc0-15ff41fc34bb:image.png)

만약 범위를 벗어난 주소 공간을 접근하면 운영체제에 트랩을 발생시키고, 운영체제는 프로세스를 중지할 가능성이 크다. 이 경우 Segment fault 에러.

### 2. 세그먼트 종류의 파악

하드웨어는 변환을 위해 세그먼트 레지스터를 사용한다. 하드웨어는 사장 주소가 어느 세그먼트를 참조하는지 그리고 그 세그먼트 안의 오프셋이 얼마인지를 어떻게 알 수 있을까?

- 가상주소의 최상위 몇 비트를 세그먼트 구분을 위한 비트로 사용. (예를 들어 코드,힙,스택 세그먼트로 나뉜 경우, 세 개의 세그먼트를 구분하기 위해 2비트가 필요.) 남은 부분을 해당 세그먼트의 오프셋으로 활용.
  ![image.png](attachment:8908c8cf-7a90-4a6a-9c09-2160ec3d612b:image.png)
- 다른 방법으로는 *묵시점 접근 방식*이 존재.

### 3. 스택

스택은 다른 세그먼트와는 다르게 반대 방향으로 확장된다. 다른 변환 방식이 필요하다.

- 간단한 하드웨어 추가. 베이스/바운드 + 세그먼트가 어느 방향으로 확장하는지 알려주는 것
  예시) 가상 주소 15KB → 물리 주소 27KB
  15KB → 11(세그먼트 비트) 1100 0000 0000(오프셋 3KB)
  음수 오프셋을 얻기 위해 3KB - 4KB(Limit Register) = -1KB
  ![image.png](attachment:9f77cff1-b23e-4a03-8248-ca0dcce8087a:image.png)

### 4. 공유 지원

특정 세그먼트 공유 가능. 특히 **코드 공유가 일반적.**

공유를 지원하기 위해 하드웨어에 protection bit의 추가가 필요하다. 세그먼트를 읽거나 쓸 수 있는지 혹은 코드를 실행시킬 수 있는지를 나타낸다.

protection bit가 추가되면 앞서 언급한 하드웨어 알고리즘이 수정되어야 한다. 가상 주소가 범위 내에 있는지 확인하는 것 이외에 특정 액세스가 허용되는지를 확인해야 한다.

### 5. 소단위 vs. 대단위 세그멘테이션

소수의 세그먼트(코드, 힙, 스택)를 대단위라고 생각할 수 있다. 주소 공간을 비교적 큰 단위의 공간으로 분할하기 때문이다. 세그먼트를 작게 분할하는 경우 소단위 세그멘테이션이라고 부른다.

많은 수의 세그먼트를 지원하기 위해 여러 세그먼트의 정보를 메모리에 저장할 수 있는 세그먼트 테이블 같은 하드웨어가 필요하다.

### 6. 운영체제의 지원

세그먼트는 새로운 문제를 제기한다.

- 문맥 교환(Context Switching) 시 운영체제는 어떤 일을 해야 하는가?
  세그먼트 레지스터의 저장과 복원이다.
- 외부 단편화
  1. Compaction을 수행 → 실행 중인 프로세스 중단, 데이터를 연속된 공간에 복사하고 세그먼트 레지스터에 새로운 값을 할당. (이는 비용이 많이 든다.)
  2. 빈 공간 리스트를 관리하는 알고리즘 → first fit,best fit, worst fit 등 많은 방식이 존재. 하지만 이러한 방식은 외부 단편화를 최소화하는 방법. 외부 단편화를 완전히 해결할 수는 없다.
