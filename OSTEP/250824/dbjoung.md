# 제한적 직접 실행 원리

CPU를 가상화하기 위해 운영체제는 CPU 시간을 나누어 쓰지만, 이런 기법을 활용하기 위해서는 몇 가지 문제를 해결해야 한다.

1. 성능 저하 : 시스템에 과도한 오버헤드를 주지 않으면서 가상화를 구현할 수 있을가?
2. 제어 문제 : CPU에 대한 통제를 유지하면서 프로세스를 효율적으로 실행시킬 수 있는 방법은 무엇인가?
   - 운영체제 입장에서는 자원 관리 책임자로서 제어 문제가 아주 중요하다. 제어권을 상실하면 한 프로세스가 영원히 CPU를 점유할 수도 있고, 접근하면 안 되는 정보에 접근하게 될 수도 있다.

→ 제어권을 유지하면서 성능 저하가 없도록 하는 것이 운영체제를 구축하는 데 핵심적인 도전 과제다.

## 기본 원리 : 제한적 직접 실행

이 아이디어의 `직접 실행`은 프로그램을 CPU에서 그냥 직접 실행시키는 것이다. 하지만 프로그램을 직접 실행시킨다면 몇 가지 문제가 발생한다.

### 문제점 1. 제한된 연산

직접 실행의 연산은 빠르게 실행된다는 것이다. 기본적으로 프로그램이 하드웨어 CPU에서 실행되기 때문이다. 하지만 CPU에서 직접 실행시키면 또 다른 문제가 발생한다.

프로세스가 특수한 종류의 연산(디스크 입출력 요청, CPU나 메모리 같은 시스템 자원에 대한 추가 할당 등)을 수행하길 원할 때, 바람직한 시스템을 구축하는 데 방해 요인이 될 수 있다.

- 예를 들어 파일에 대한 접근을 허용하기 전에 접근 권한을 검사하는 파일 시스템이 있다고 해보자.
  - 프로세스가 디스크에 대하여 입출력 하는 것을 제한하지 않으면, 프로세스는 전체 디스크를 읽고 쓸 수 있기 때문에 접근 권한을 검사하는 기능이 아무런 의미가 없다.

위 문제를 해결하기 위해 `사용자 모드(User Mode)` 라는 이름의 새로운 모드가 도입되었다. 사용자 모드에서 실행되는 코드는 할 수 있는 일이 제한된다.

- 예 ) 프로세스가 사용자 모드에서 실행 중이면 입출력 요청을 할 수 없도록 설정. → 이때 입출력 요청을 하면 프로세서가 예외를 발생시키고, 운영체제는 해당 프로세스를 제거.

‘

`커널 모드(Kernel Mode)`는 사용자 모드와 대비되는 모드로서 운영체제의 중요한 코드들이 실행된다.

- 이 모드에서 실행되는 코드는 모든 특수한 명령어를 포함하여 원하는 모든 작업을 수행 가능.

그렇다면, `사용자 모드` 의 프로세스가 디스크 읽기와 같은 특권 명령어를 실행시키기 위해서는 어떻게 해야 하는가?

- 이런 **제한 작업의 실행을 허용**하기 위해 거의 모든 현대 하드웨어는 사용자 프로세스에 **시스템 콜**을 제공한다.
  - Atlas와 같은 커널은 시스템 콜을 통하여 자신의 주요 기능(파일 시스템 접근, 프로셋 ㅡ생성 및 제거, 다른 프로세스와의 통신 및 메모리 할당 등)을 사용자 프로그램에게 제공한다.
  - 시스템 콜을 실행하기 위해 프로그램은 `trap 특수 명령어`를 실행해야 한다. 이 명령어는 커널 안으로 분기하는 동시에 특권 수준을 커널 모드로 상향 조정한다. 모든 명령이 실행되면 운영체제는 이번에는 `return-from-trap` 특수 명령어를 호출한다. 특권 수준을 다시 사용자 모드로 하향 조정하면서 호출한 사용자 프로그램으로 리턴한다.
- 커널은 부팅 시에 **트랩 테이블(Trap Table)**을 만들고 이를 이용해 시스템을 통제한다. 컴퓨터가 부트될 때 커널 모드에서 동작하기 때문에 하드웨어를 원하는대로 제어할 수 있다.

  - 운영체제의 초기 작업 중 하나는 하드웨어에게 **예외 사건이 일어났을 때 어떤 코드를 실행해야 하는지 알려주는 것**이다. (ex. 하드 디스크 및 키보드 인터럽트가 발생했을 때, 그리고 프로그램이 시스템 콜을 호출했을 때 무슨 코드를 실행해야 하는가?)

    - 이를 위해 운영체제는 특정 명령어를 사용해 하드웨어에게 **트랩 핸들러의 위치**를 알려주는 것. 하드웨어는 이 정보를 기억하고 있다가 예외 사건이 발생했을 때 어느 코드로 분기할 지를 알 수 있다.
      <aside>
      💡

      왜 굳이 트랩 핸들러를 사용해야 하는가?

      trap 명령어는 운영체제 코드의 어디를 실행해야 하는 지 알 지 못한다. 호출한 프로세서는 분기할 주소를 명시할 수 없기 때문이다. 주소를 명시한다는 것은, 커널 내부의 원하는 지점에 접근할 수 있다는 것이기 때문에 위험하다.

      </aside>

제한된 직접 실행 프로토콜(LDE 프로토콜)은 두 단계로 진행된다.

- 전반부(부팅 시)

  - 커널은 트랩 테이블을 초기화한다.
  - CPU는 나중에 사용하기 위해 테이블의 위치를 저장한다.

  - 커널은 이러한 작업을 커널 모드에서만 사용할 수 있는 명령어를 이용하여 수행한다.

- 후반부(프로세스 실행 시)
  - return-from-trap을 이용하여 사용자 프로세스를 시작한다.
    - 새로운 프로세스를 위한 노드를 할당해 프로세스 리스트에 삽입하고 메모리를 할당하는 등의 작업을 함
  - CPU를 사용자 모드로 전환하고 프로세스 실행을 시작
  - 프로세스가 시스템 콜을 호출하면 운영체제로 다시 트랩
  - 시스템 콜을 처리한 후 `return-from-trap` 명령어를 사용해 다시 제어를 프로세스에게 넘김
  - 프로세스는 할 일이 끝나면 `main()`에서 리턴
    - 일반적으로 스텁 코드로 리턴하고, 스텁 코드가 프로그램을 종료 시킨다. (`exit()` 시스템을 호출하고 다시 운영체제로 트랩됨)
  - 운영체제는 정리 작업을 하여 모든 일이 완료

## 문제점 2: 프로세스 간 전환

직접 실행의 두 번째 문제점은 프로세스 간 전환을 간단하게 구현할 수 없다는 점이다.

운영체제는 실행 중인 프로세스를 계속 실행할 것인지, 멈추고 다른 프로세스를 실행할 것인지를 결정해야 한다. 하지만 CPU에서 프로세스가 실행 중이라는 것은 운영체제는 실행중이지 않다는 것을 의미한다. 운영체제가 실행 중이지 않은 데, 프로세스 간 전환이 어떻게 가능하냐는 그런 말인 것이다.

**Q. 운영체제는 CPU를 어떻게 다시 획득하여 프로세스를 전환할 수 있을까?**

### 협조 방식 : 시스템 콜 기다리기.

협조(Cooperative) 방식으로 알려진 이 방법은 과거의 몇몇 시스템에서 채택되었다. 이 방식에서는 운영체제가 프로세스들이 합리적으로 행동할 것이라고 신뢰한다. 너무 오랫동안 실행할 가능성이 있는 프로세스는 운영체제가 다른 작업을 실행할 결정을 할 수 있도록 주기적으로 CPU를 포기할 것이라고 가정한다.

`yield` 시스템 콜은 운영체제에게 제어를 넘겨 운영체제가 다른 프로세스를 실행할 수 있게 한다. 응용 프로그램이 비정상적인 행위를 하게 되면 운영체제에게 제어가 넘어간다.

- 예를 들어 어떤 수를 0으로 나누는 연산을 실행하거나 접근할 수 없는 메모리에 접근하려고 하면, 운영체제로의 `trap`이 발생한다.

협조 방식의 스케줄링 시스템에서 운영체제는 시스템 콜이 호출되기를 기다리거나 불법적인 연산이 일어나기를 기다려서 CPU의 제어권을 다시 획득한다.

하지만 이 방법은, 만약 프로세스가 무한 루프에 빠져 시스템 콜을 호출할 수 없을 때 대처 방법이 없을 것이다.

### 비협조 방식 : 운영체제가 전권을 행사

협조적 방법에서 프로세스가 무한 루프에 빠졌을 때 조치할 수 있는 방법은 컴퓨터 재부팅 밖에 없다. 그렇다면, 협조 없이 제어를 얻는 방법은 뭐가 있을까?

이 해결책은 **타이머 인터럽트**를 이용하는 것이다. 인터럽트가 발생하면 현재 수행 중인 프로세스는 중단되고 미리 구성된 운영체제의 **인터럽트 핸들러**가 실행된다. 이 시점에 운영체제는 CPU 제어권을 다시 얻어 현재 프로세스를 중단하고 다른프로세스를 실행시키는 작업이 가능해지다.

운영 체제는 하드웨어에게 타이머 인터럽트가 발생했을 때 실행해야 할 코드를 알려주어야 한다. 부팅될 때 운영체제가 이런 준비를 한다. 부팅 과정 진행 중에 운영체제는 타이머를 시작한다.

### 문맥의 저장과 복원

시스템 콜을 사용해 협조적으로 하던, 타이머 인터럽트를 통해 약간은 강제적으로 하던, 운영체제가 제어권을 다시 획득하려면 중요한 결정을 내려야 한다.

- 현재 실행 중인 프로세스를 계속 실행할 것인지, 아니면 다른 프로세스로 전환할 것인지.
- 이 결정은 운영체제의 **스케줄러**가 수행한다.

다른 프로세스로 전환하기로 결정되면 운영체제는 **문맥 교환(Context Switch)라고 알려진 코드를 수행한다.**

- `문맥 교환` : 운영체제가 해야 하는 작업은 현재 실행 중인 프로세스의 레지스터 값을 커널 스택 같은 곳에 저장하고, 곧 실행될 프로세스의 커널 스택으로부터 레지스터 값을 복원하는 것
  → 이 과정을 통해 운영체제는 `return-from-trap` 명령어가 마지막으로 실행될 때, 현재 실행 중이던 프로세스가 아닌 다른 프로세스로 리턴하여 실행을 다시 시작할 수 있다.

### 병행성이 걱정

그렇다면, 만 운영체제가 인터럽트 또는 트랩을 처리하는 도중 다른 인터럽트가 발생했을 때는 어떻게 해야할까? 이 내용은 두 번째 파트인 **병행성**에서 자세히 얘기하고 있다.

다만, 이 상황의 가장 간단한 해법은 **인터럽트를 처리하는 동안 인터럽트를 불능화 시키는 것**이다.

운영체제는 병행성을 해결하기 위해 정교하고 다양한 **락(Lock) 기법**을 개발해왔다. 이 잠금 기법은 커널 안에서 동시에 다수의 활동이 진행될 수 있게 허용한다.

---

# 스케줄링

이 장에서는 다양한 스케줄링 정책을 소개하고 그에 관한 이해를 높일 것이다. 이러한 정책은 원칙이라고도 불린다.

일단, 스케줄링 정책은 어떻게 개발하는가?

## 워크로드에 대한 가정

가장 먼저 프로세스에 대해 몇 가지 가정을 해야한다. 일련의 프로세스들이 실행하는 상황을 **워크로드**라고 부르기로 한다. 워크로드를 결정하는 것은 정책 개발에 매우 중요하다.

## 스케줄리 평가 항목

스케줄링 정책의 비교를 위해 스케줄링 평가 항목(Scheduling Metric)을 결정해야 한다. 다양한 평가 기준이 존재한다. 반환 시간의 경우는 아래와 같다.

1. 반환 시간 :
   - 작업 반환 시간은 작업이 완료된 시각에서 작업이 시스템에 도착한 시간을 뺀 시간이다.
   - 반환 시간은 성능 측면에서의 평가 기준이다.
     - 다른 평가 기준으로는 **공정성**이 있다. 공정성과 성능은 스케줄링에서 서로 상충되는 목표다. 예를 들어, 스케줄러는 성능을 극대화하기 위해 몇몇 작업의 실행을 중지시키고, 이는 공정하다가 볼 수 없을 것이다.

## 선입 선출

가장 기초적인 알고리즘은 선입선출(FIFO) 또는 선도착처리(FCFS) 스케줄링이다. 하지만 이 스케줄링은 첫 번째 작업의 반환 시간이 길수록 전체 평균 반환 시간, 즉 성능에 악영향을 준다.

따라서 그러한 워크로드에서는 좋지 못한 알고리즘이다.

- **Tip** : 짧은 시간 동안 자원을 사용할 프로세스들이 자원을 오랫동안 사용하는 프로세스의 종료를 기다리는 현상을, **convoy effect라 칭한다.**

## 최단 작업 우선

**convoy effect** 문제는 최단 작업 우선(Shortest Job First, SJF)로 간단하게 해결할 수 있다. 이 원칙은 가장 짧은 실행 시간을 가진 작업을 먼저 실행시킨다. 모든 작업이 동시에 도착한다면 SFJ는 최적 스케줄링임이 틀림 없다.

하지만 가장 긴 작업이 첫번째로 도착해 실행에 들어가고, 그 뒤로 짧은 작업들이 들어온다면 또다시 **convoy effect** 문제에 당면한다.

## 최소 잔여시간 우선

타이머 인터럽트와 문맥 교환을 사용하면 짧은 작업이 도착했을 때 긴 작업을 중지하고 짧은 작업을 실행하기로 결정할 수 있다. SJF는 **비선점형 스케줄러** 이기 때문에 이와 같은 동작을 수행하지 못한다.

SJF에 선점 기능을 추가한 _최단 잔여시간 우선(Shortest Time-to-Completion First, STCF)_ 또는 *선점형 최단 작업 우선(PSJF)*은 위와 같은 작업이 가능한 **선점형 스케줄러**이다.

- 현대의 대부분의 스케줄러는 선점형 스케줄러 방식을 채택하고 있다.

언제든 새로운 작업이 시스템에 들어오면, 스케줄러는 남아 있는 작업과 새로운 작업의 잔여 실행 시간을 계산하고 그 중 가장 적은 잔여 실행 시간을 가진 작업을 스케줄한다.

## 새로운 평가 기준: 응답 시간

작업의 길이를 알고있고, 작업이 오직 CPU만을 사용하며, 평가 기준이 반환 시간 하나인 환경에서 SCTF는 매우 훌륭한 정책이었다.

하지만 시분할 컴퓨터의 등장이 모든 것을 바꿨다. 이제 사용자는 터미널에서 작업하게 되어 시스템에게 상호작용을 원활히 하기 위한 성능을 요구하게 됐다.

그에 따라 **응답 시간**이라는 새로운 평가 기준이 태어났다.

- 응답 시간 : 작업이 도착할 때부터 처음 스케줄 될 때까지의 시간

반환 시간만 고려했던 앞의 스케줄 정책들은 응답 시간이 짧다고 할 수 없다.

## 라운드 로빈

응답 시간 문제를 해결하기 위해 **라운드 로빈** 스케줄링이라 불리는 알고리즘을 도입했다.

RR은 작업이 끝날 때까지 기다리지 않는다. 대신 **일정 시간 동안 실행한 후 실행 큐의 다음 작업으로 전환**한다.

이때 **작업이 실행되는 일정 시간**을 **타임 슬라이스** 또는 **스케줄링 퀀텀**이라 부른다. 작업이 완료될 때까지 이런 식으로 계속 진행된다. 이러한 이유로 RR는 때때로 **타임 슬라이싱**이라고 불린다.

타임 슬라이스의 길이는 타이머 인터럽트 주기의 배수여야 한다. 타임 슬라이스의 길이가 짧을 수록 응답 시간 기준으로 RR의 성능은 더 좋아진다.

하지만 타임 슬라이스 길이를 너무 짧게 설정하면 문맥 교환 비용이 전체 성능에 큰 영향을 미치게 된다.

타임 슬라이스는 문맥 교환 비용을 상쇄할 수 있을 만큼 길어야 하지만, 그렇다고 응답 시간이 너무 길어지지 않도록 설정되어야 한다.

- 문맥 교환 비용에는 레지스터를 저장/복원하는 작업만 있는게 아니다. CPU 캐시, TLB, 분기 예측 등을 비롯하여 다른 하드웨어에도 프로그램과 관련된 다양한 작업 정보들이 저장돼있다. 작업이 전환되면 이 정보들은 모두 갱신되어야 한다.

만약 성능 측정 기준이 반환 시간만 있자면 RR은 그야말로 최악이다. RR은 각 작업을 잠깐 실행하고 넘어가면서 각 작업의 실행 시간을 늘리는 것이 목표이기 때문이다. 일반적으로 RR과 같은 **공정한** 정책(즉, 작은 시간 단위로 모든 프로세스에게 CPU를 분배하는 정책)은 반환 시간과 같은 평가 기준에서는 성능이 나쁘다.

- 불공정하게 한다면 하나의 작업을 끝까지 실행하고 종료할 수 있지만 응답 시간이 늘어난다.
- 공정하게 한다면 각 작업에 공평하게 CPU를 분배할 수 있지만 반환 시간이 늘어난다.

## 입출력 연산의 고려

입출력 작업을 요청한 경우 스케줄러는 다음에 어떤 작업을 실행할지를 결정해야 한다. 현재 실행 중인 작업은 입출력이 완료될 때까지 CPU를 사용하지 않을 것이기 때문이다. 입출력 요청을 발생시킨 작업은 입출력 완료를 기다리며 대기 상태가 된다.

따라서 그 시간동안 실행시킬 다른 프로세스를 스케줄 해야한다.

입출력이 완료됐을 시점에도 이 결정은 필요하다.

결정 정책 중의 하나로 **RR + STCF 스케줄러**를 구축해볼 수 있다. 작업 A의 타임 슬라이스는 10msec이고 작업 B는 입출력이 없다. 이 경우, 작업 A의 각 타임 슬라이싱을 하나의 작업으로 취급하면 스케줄러는 작업 A부터 실행을 시작한다.

그리고 10msec 후 입출력 작업이 시작되어 cpu가 비었을 때 STCF 원칙에 따라 작업 B를 수행하게 된다. A의 입출력이 끝나고 A작업이 대기 상태에서 다시 준비 상태가 되면, STCF 원칙에 따라 더 짧은 작업인 A의 타임 슬라이스를 다시 채택하게 된다.

## 만병 통치약은 없다

사실, 여태까지 살펴본 스케줄링 원칙들은 전부 작업의 실행 시간을 알고 있다는 가정을 기반으로 한다. 하지만 범용 운영체제에서 작업의 길이에 대해 알 수 있는 길은 없다.

따라서 아무런 사전 지식 없이 SJF/STCF 처럼 행동하는 알고리즘 구축이 가능할까? 게다가, 응답 시간도 좋게 하기 위해 RR 스케줄러의 경우에 보았던 아이디어를 어떻게 하면 포함할 수 있을까?

이에 대한 답은 다음 장인 **멀티 레벨 피드백 큐**에 있다.

---

---

# 발표 주제 : 커널 스택 (Kernel Stack)

### OSTEP 속 `커널 스택` 에 대한 이야기

- 운영체제가 return-from-trap 명령어 실행 시 사용자 프로세스로 제대로 리턴할 수 있도록 하기 위함이다. 예를 들면, x86에서는 프로그램 카운터, 플래그와 다른 몇 개의 레지스터를 각 프로세스의 `커널 스택(kernel stack)`에 저장한다. return-from-trap 명령어가 이 값들을 스택에서 팝 (pop)하여 사용자 모드 프로그램의 실행을 다시 시작한다.
- 프로세스는 `커널 스택`을 각자 가지고 있다. 커널 모드로 진입하거나 진출할 때 하드웨어에 의해 프로그램 카운터와 범용 레지스터 등의 레지스터가 저장되고 복원되는 용도로 사용된다.
- 인터럽트 발생 시 하드웨어에게도 약간의 역할이 있다. 인터럽트가 발생했을 때 실행 중이던 프로그램의 상태를 저장하여 나중에 return-from-trap 명령어가 프로그램을 다시 시작할 수 있도록 해야 한다. 이러한 일련의 동작은 시스템 콜이 호출되었을 때 하드웨어가 하는 동작과 매우 유사하다. 다양한 레지스터가 `커널 스택`에 저장되고, return-from-trap 명령어를 통하여 복원된다.
- 문맥 교환은 개념적으로는 간단하다. 운영체제가 해야 하는 작업은 현재 실행 중인 프로세스의 레지스터 값을 `커널 스택` 같은 곳에 저장하고 곧 실행될 프로세스의 커널 스택으로부터 레지스터 값을 복원하는 것이 전부다. 그렇게 함으로써 운영체제는 return-from-trap 명령어가 마지막으로 실행될 때 현재 실행 중이던 프로세스로 리턴하는 것이 아니라 다른 프로세스로 리턴하여 실행을 다시 시작할 수 있다.
- 프로세스 전환을 위하여 운영체제는 저수준 어셈블리 코드를 사용하여 현재 실행 중인 프로세스의 범용 레지스터, PC뿐 아니라 현재 `커널 스택 포인터`를 저장한다. 그리고 곧 실행될 프로세스의 범용 레지스터, PC를 복원하고 `커널 스택`을 이 프로세스의 `커널 스택`으로 전환한다. 이로써 운영체제는 인터럽트된 프로세스 문맥에서 전환 코드를 호출하고, 실행될 프로세스 문맥으로 리턴할 수 있다. 운영체제가 마지막으로 returnfrom-trap 명령어를 실행하면 곧 실행될 프로세스가 현재 실행 중인 프로세스가 된다. 그래서 문맥 교환이 마무리 된다.
- A의 프로세스 구조체에 저장하고 B의 프로세스 구조체에서 B의 레지스터를 복원한다. 그런 후에 A의 `커널 스택`이 아니라 B의 `커널 스택`을 사용하도록 스택 포인터를 꾸어서 문맥 교환을 수행한다.
- 이 과정이 실행되는 동안 두 번의 레지스터의 저장/복원이 일어난다는 것에 주의하자. 첫 번째는 타이머 인터럽트가 발생했을 때 일어난다. 이 경우 실행 중인 프로세스의 사용자 레지스터가 하드웨어에 의해 암ྖ적으로 저장되고 저장 장소로 해당 프로세스의 `커널 스택`이 사용된다. 두 번째는 운영체제가 A에서 B로 전환하기로 결정했을 때 일어난다. 이 경우 커널 레지스터는 운영체제에 의하여 해당 프로세스의 **프로세스 구조체**에 저장된다. 이것은 운영체제가 A가 아닌 B로부터 커널로 트랩된 것처럼 만든다.

## 커널 스택이란?

가상 메모리(각 프로세스의 독립된 주소 공간)는 사용자 공간과 커널 공간으로 구분되며, 두 공간 모두 스택 자료구조를 기반으로 관리된다. 때문에 커널 스택, 사용자 스택이라고도 불린다.

커널 스택은 커널 모드일 때, 사용자 스택은 사용자 모드일 때만 접근할 수 있다.

책에서 언급했듯이, 커널 스택은 프로세스마다 하나씩 존재한다.

프로세스가 시스템 콜을 통해 커널 모드로 진입했을 때 사용하게 되는 커널 스택 공간이다.

- 프로세스가 read()나 write() 같은 시스템 콜을 호출하면 CPU는 트랩 명령어(trap)를 실행해 커널 모드로 진입한다.

또한, 프로세스 간 문맥 교환이 발생할 시점의 CPU 컨텍스트를 저장하는 용도로 사용된다.

- CPU 컨텍스트 : CPU 주요 정보의 Snapshot. 문맥 교환이 발생할 시점의 레지스터 정보 같은 것들이 해당 될 것이다.

문맥 교환은 프로세스 종료나 인터럽트에 의해 발생한다. 그 순서는 다음과 같다.

1. 인터럽트 or 시스템 콜 발생

- CPU는 **현재 실행 중인 프로세스 A의 사용자 레지스터**를 A의 커널 스택에 Push 한다.
- 커널 모드로 진입해서 인터럽트 핸들러를 실행한다.
- 인터럽트 처리가 끝나면 OS 스케줄러는 다음 작업을 결정한다.
  - 다시 A 프로세스로 돌아갈 지, (더 우선순위가 높은) B 프로세스로 진입할 지

2-1. A 작업으로 복귀할 경우

- A 프로세스의 커널 스택에서 CPU 컨텍스트를 Pop하여 사용자 레지스터 정보 등을 복구시킨다.
- A 프로세스를 이어서 처리한다.

2-2. B 작업으로 진입할 경우 (문맥 교환)

- A 프로세스의 PCB(프로세스 제어 블록)에 A의 커널 스택 포인터, 커널 레지스터 값 등 추가적인 문맥 정보를 저장한다.
- B의 PCB를 읽어 와서 B의 CPU 컨텍스트를 CPU 레지스터에 복원한다.
- B의 커널 스택을 활성화한 뒤, B를 이어서 실행시킨다.

User Stack은 아래의 요소들로 구성되어 있다.

- 지역 변수
- 함수 매개 변수
- 프레임 포인터 : 중첩된 함수 호출에서 지역 변수 및 함수 매개 변수를 식별할 수 있도록 한다.
- 반환 주소 : 함수 실행이 끝나면 호출자의 위치를 나타내는 반환 주소가 User Stack에 Push 된다.
- 자동 변수 : 함수 매개 변수 및 지역 변수를 포함하여 블록 범위 내에서 선언 변수가 사용자 스택에 저장된다.
- 임시 값 : 중간 결과 또는 함수 호출 간에 전달되는 값과 같은 임시 데이터가 User Stack에 저장될 수 있다.

## PCB (프로세스 제어 블록) 이란?

운영체제가 프로세스를 제어하기 위해 정보를 저장해 놓은 곳. 프로세스의 상태 정보를 저장하는 구조체다.

프로세스 상태 관리와 문맥 교환을 위해 필요하다.

PCB는 프로세스 생성 시 만들어지며, 주기억장치에 유지된다. (즉, 커널 스택과 마찬가지로 프로세스 마다 개별적인 PCB를 갖는다.)

### PCB에 포함되는 정보들

- Process ID : 프로세스를 구분하는 ID
- Process state : 각 State 들의 상태를 저장한다.
- Program Counter : 이 프로세스에서 실행될 다음 명령의 주소에 대한 포인터.
- Register : Accumulator, CPU Register, General Register 등을 레지스터 관련 정보.
- CPU Scheduling Information : 우선순위, 최종 실행시간, CPU 점유시간 등이 포함된다.
- Memory Information : 해당 프로세스 주소공간(lower bound ~ upper bound) 정보를 저장
- Process Information : 페이지 테이블, 스케줄링 큐 포인터, 소유자, 부모 등
- Device I/O Status : 프로세스에 할당된 입출력 장치 목록, 열린 목록등
- Pointer : 부모/자식 프로세스에 대한 포인터, 자원에 대한 포인터 등
- Open File List : 프로세스를 위해 열려있는 파일의 리스트

### 문맥 교환에서의 PCB의 역할

- 커널 스택에서 살펴봤던 문맥 교환의 순서를 그대로 따른다. 다만, 더 세부적으로 살펴보면 두 가지 경우로 나눌 수 있다.

1. A 프로세스에서 인터럽트가 발생했다가, 다시 A 프로세스로 돌아오는 경우

- 해당 경우 A 프로세스는 현재 정보를 PCB에 저장할 필요가 없다. 왜냐하면 CPU 컨텍스트를 A 커널 스택에 Push/Pop 하는 것으로 해결할 수 있기 때문이다.
- 해당 경우는 A 프로세스를 그대로 실행하는 것이기 때문에 문맥 교환이 아니다.

1. A 프로세스에서 B 프로세스로 문맥 교환 할 경우

- CPU는 B 프로세스를 실행하기 전, A 프로세스의 커널 스택 정보와 기타 필요한 정보들을 PCB에 복사하여 저장한다. 이 작업을 통해, CPU는 이후 다시 A 프로세스로 돌아왔을 때 작업을 이어서 진행할 수 있다.

![image.png](attachment:9f55b41b-229e-4015-a96c-038c81bc13bc:image.png)

## 자료 출처

https://blog.naver.com/lache96/140051813931

https://velog.io/@junhyeok_kim/CS-KEYWORD-User-Stackand-Kernel-Stack

https://jettstream.tistory.com/149

https://walwaldev.tistory.com/137
