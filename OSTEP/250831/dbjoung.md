# 스케줄링 : 멀티 레벨 피드백 큐

멀티 레벨 피드백 큐 (MLFQ)가 해결하려고 하는 기본적인 문제는 두 가지다.

- 짧은 작업을 먼저 실행시켜 `반환 시간` 을 최적화
  - SJF나 STCF같은 알고리즘은 작업의 실행 시간 정보를 토대로 반환 시간을 줄이지만, 실제 환경에서 운영체제는 작업의 실행 시간을 미리 알 수 없다.
- `응답 시간`을 최적화
  - RR 알고리즘은 응답 시간을 최소화하지만 반환 시간은 거의 최악이다.

Q. 작업의 시랭 시간에 대한 선행 정보 없이 대화형 작업의 응답 시간을 최소화하고 동시에 반환 시간을 최소화하는 스케줄러를 어떻게 설계할 수 있을까

## 11.1 MLFQ 기본 규칙

- 여러 MLFQ들은 자세히 보면 차이가 있지만 기본적으로 비슷한 방법을 사용한다.
- MLFQ는 여러 개의 큐로 구성되며, 각각 다른 **우선순위**가 배정된다.
  - 실행 준비가 된 프로세스는 이 중 하나의 큐에 존재한다.
  - 실행할 큐를 결정하기 위해 우선순위를 사용한다.
  - 높은 우선순위를 가진 작업이, 즉 **높은 우선순위 큐에 존재하는 작업**이 선택된다.
  - 큐에 **둘 이상의 작업이 존재할 수 있다. 이들은 모두 같은 우선순위를 가진다.**
    - 이 작업들 사이에는 `라운드 로빈` 스케줄링 알고리즘이 사용된다.
- MLFQ의 핵심은 우선순위를 정하는 방식이다.
  - 각 작업에 고정된 우선순위를 부여하는 것이 아니라, 각 작업의 특성에 따라 동적으로 우선순위를 부여한다.
    - 예를 들어 어떤 작업이 키보드 입력을 기다리며 반복적으로 CPU를 양보하면 MLFQ는 해당 작업의 순위를 높게 유지한다.
    - 대신 한 작업이 긴 시간 동안 CPU를 집중적으로 사용하면 MLFQ는 해당 작업의 우선순위를 낮춘다.
    - MLFQ는 위와 같이 작업이 진행되는 동안 해당 작업의 정보를 얻고, 이 정보를 이용하여 **미래 행동을 예측**한다.
- MLFQ의 두 가지 기본 규칙은 다음과 같다.
  - **_규칙 1 : Priority(A) > Priority(B) 이면, A가 실행된다. (B는 실행x)_**
  - **_규칙 2 : Priority(A) = Priority(B) 이면, A와 B는 RR 방식으로 실행된다._**

하지만 위와 같은 규칙으로는 낮은 우선순위 큐의 작업들은 높은 우선순위 큐의 작업들이 전부 완료되기 전에는 CPU를 할당받지 못할 것이다.

이를 어떻게 해결했는지 알기 위해서는, 작업 우선순위가 시간에 따라 어떻게 변화하는 지를 알아야 한다.

## 11.2 시도 1 : 우선순위의 변경

작업의 우선순위를 변경하는 것은 작업이 존재할 큐를 결정하는 것과 마찬가지다.

짧은 실행 시간을 갖는 `CPU를 자주 양보하는 대화형 작업`과 많은 CPU 시간을 요구하지만 `응답 시간은 중요하지 않은 긴 실행 시간의 CPU 작업`이 혼재되어 있다.

우선 순위 조정 알고리즘을 위한 첫 번째 시도는 다음과 같다.

- **_규칙 3 : 작업이 시스템에 진입하면, 가장 높은 우선순위, 즉 맨 위의 큐에 놓여진다._**
- **_규칙 4A : 주어진 타임 슬라이스를 모두 사용하면 우선순위는 낮아진다. 즉, 한 단계 아래 큐로 이동한다._**
- **_규칙 4B : 타임 슬라이스를 소진하기 전에 CPU를 양도하면 같은 우선순위를 유지한다._**

### 예시 1. 한 개의 긴 실행 시간을 가진 작업

먼저, 어떻게 **MSFQ가 SJF에 근접할 수 있는 지**(SJF의 장점 : 짧은 반환 시간)를 알아본다.

하나의 긴 실행시간을 가진 작업이 들어올 경우, 다음과 같은 순서를 따른다.

1. 우선순위가 가장 높은 큐에 작업을 할당한다.
2. 10 msec 타임 슬레이스가 하나 지나면 작업을 다음 우선순위의 큐로 이동시킨다.
3. 또 타임 슬라이스가 하나 지나면, 마찬가지로 다음 우선순위 큐로 내린다.
4. 위 작업을 반복하다보면 작업은 가장 낮은 우선순위의 큐에 도착하게 되고, 해당 큐에서 작업을 마무리한다.

### 예시 2. 짧은 작업과 함께

이번 예에서는 2개의 작업이 존재한다.

- A : 오래 실행되는 CPU 위주의 작업. 이미 얼마 동안 실행 중인 상태.
- B : 짧은 대화형 작업. 이제 막 도착함.

이 경우, A는 이미 얼마 간 실행 중인 상태였기 때문에 새로 할당된 B보다 낮은 우선순위의 큐에 들어가 있다. 따라서 MLFQ 스케줄러는 B의 타임 슬라이스를 먼저 실행시키게 되며, B는 짧은 작업이기 때문에 A가 머물러 있는 큐까지 도달하지 않고 마무리된다.

이후 A가 이어서 실행되어 마무리된다.

이 예시에서, MLFQ 알고리즘의 **주요 목표**를 알 수 있다.

- 스케줄러는 작업이 짧은 지 긴 지 알 수 없기 때문에 일단 짧은 작업이라고 가정하고 가장 높은 우선순위 큐에 할당한다. 진짜 짧은 작업이면 빠르게 실행되고 종료될 것이며, 그렇지 않다면 낮은 우선순위 큐로 이동하여 스스로 긴 작업이라는 사실을 증명하게 될 이다.
- 이러한 방식으로 **MLFQ는 SJF와 근사할** 수 있다.

### 예시 3. 입출력 작업에 대해서는 어떻게?

이번에는 **응답 시간**을 어떻게 개선할 수 있는 지 알아보자.

규칙 4B에서처럼 프로세스가 타임 슬라이스를 소진하기 전에 프로세서를 양도하면 같은 우선순위를 유지하게 한다.

- 이 규칙의 의도 : 대화형 작업이 키보드나 마우스로부터 사용자 입력을 대기하며 자주 입출력을 수행하면 타임 슬라이스가 종료되기 전에 CPU에 양도하게 될 것.
- 이 결과, 입출력 작업은 항상 최상위 우선순위 큐에 머물 수 있게 된다.

## 11.2-2 여태까지 설계에서의 결점

위 예시 3까지 살펴본 바로, 이와 같은 로직을 갖춘 MLFQ는 잘 작동할 것 처럼 보인다. 하지만 아래와 같은 아주 중대한 결점이 있다.

### 첫 번째 : 기아 상태(Starvation)가 발생할 수 있다.

시스템에 너무 많은 대화형 작업이 존재하면 그들이 모든 CPU 시간을 소모하게 될 것이고, 따라서 긴 실행 시간 작업은 CPU 시간을 할당 받지 못할 것이다.

### 두 번째 : 사용자의 조작

사용자가 스케줄러를 속여서 지정된 몫보다 더 많은 시간을 할당하도록 하게 만들 가능성이 있다. 지금까지 논의한 알고리즘은 다음과 같은 공격에 취약하다.

- 타임 슬라이스가 끝나기 전에 아무 파일을 대상으로 입출력 요청을 내려 CPU를 양도한다.
- 위의 방법으로 같은 큐에 계속 머물게 하여 우선 순위를 유지한다.
- 예를 들어, 타임 슬라이스의 99%를 소모하고 작업을 양도하면 계속 CPU를 독점할 수 있는 것.

### 마지막 : 프로그램은 시간 흐름에 따라 특성이 변할 수 있다.

CPU 위주의 작업이 대화형 작업으로 바뀔 수 있다. 현재 구현 방식으로는 그런 작업은 운이 없게도 다른 대화형 작업들과 같은 대우를 받을 수 없다.

## 11.3 시도 2 : 우선순위의 상향 조정

규칙을 보완하여 기아 문제를 방지해보자.

CPU 위주 작업을 조금이라도 진행하기 위해서는 무엇을 할 수 있을까?

간단한 방법으로는 모든 작업의 우선 순위르리 주기적으로 **상향 조정**하는 것이다.

- **_규칙 5 : 일정 기간 S가 지나면, 시스템의 모든 작업을 최상위 큐로 이동시킨다._**

이 새 규칙은 아래 두 가지를 보장한다.

- 기아 문제 : 최상위 큐에 존재하는 동안 작업은 다른 높은 우선순위 작업들과 라운드 로빈 방식으로 CPU를 공유하게 되고 서비스를 받는다.
- CPU 위주 작업이 대화형 작업으로 변할 경우 우선순위 상향을 통해 스케줄러가 변경된 특성에 적합한 스케줄링 방법을 적용.

S를 얼마로 설정해야 할 지 결정해야 한다는 과제가 남아있긴 하지만, 이는 명확하게 정할 수 있을 그런 단위는 아니다.

- 너무 크면 긴 실행 시간을 가진 작업은 굶을 수 있으며, 너무 작으면 대화형 작업이 적절한 양의 CPU 시간을 사용할 수 없게 됨.
- 이런 종류의 값을 **부두 상수**라고 부른다.

## 11.4 더 나은 시간 측정

하지만 해결해야 할 문제가 하나 더 남았다.

스케줄러를 자신에게 유리하게 동작시키는 문제를 해결하기 위해서는 어떻게 해야할까?

⇒ MLFQ의 각 단계에서 CPU 총 시간을 측정하여 해결할 수 있다.

- 스케줄러는 현재 단계에서 프로세스가 소진한 CPU 사용 시간을 저장한다.
- 프로세스가 타임 슬라이스에 해당하는 시간을 모두 소진하면 다음 우선순위 큐로 강등된다.
- 타임 슬라이스를 한 번에 소진하든, 짧게 여러 번 소진하든 상관 없이 정해진 스해진 타임을 소진하면 강등되는 것이다.
- 즉, **규칙 4A와 4B를 합쳐서 하나의 규칙**으로 재정의 한 것이다.

**_규칙 4 : 주어진 단계에서 시간 할당량을 소진하면(CPU 양도와 상관 없이), 우선 순위는 낮아진다._**

## 11.5 MLFQ 조정과 다른 쟁점들

MLFQ 스케줄링에는 어려 다른 쟁점들이 남아 있다.

필요한 변수들을 스케줄러가 어떻게 설정해야 하는지도 중요한 문제다.

ex) 몇 개의 큐가 존재해야 하는가?, 큐 당 타임 슬라이스 크기는?, S의 사이즈는?, 등

이러한 질문들은 워크로드에 대해 충분히 경험하고 계속 조정해 나가며 균형점을 찾아야 한다.

### ex. Solaris MLFQ

Solaris의 MLFQ는 프로세스의 우선순위가 일생 동안 어떻게 변하는지, 타임 슬라이스의 길이는 얼마인지, 작업의 우선순위는 얼마나 자주 상향되는지를 결정하는 테이블을 제공한다. 관리자는 이 테이블을 수정하여 스케줄러의 동작 방식을 바꿀 수 있다.

### ex. FreeBSD

반면 다른 MLFQ 스케줄러는 테이블이나 이 장에서 설명한 명확한 규칙 같은 것은 사용하지 않는다.

수학 공식을 사용하여 우선순위를 조정한다.

FreeBSD의 스케줄러(4.3 버전)는 작업의 현재 우선순위를 계산하기 위해 프로세스가 사용한 CPU 시간을 기초로 한 공식을 사용한다. (감쇠-사용 알고리즘)

### 스케줄러의 다른 기능들

마지막으로 스케줄러들은 다른 여러 기능을 제공한다.

- 일부 스케줄러의 경우 가장 높은 우선순위를 운영체제 작업을 위해 예약해 둔다.
- 일부 시스템은 사용자가 우선순위를 저앟는 데 도움을 줄 수 있도록 허용한다.

## MLFQ 요약

### 기본 규칙 정리

- 규칙 1 : Priority(A) > Priority(B) 이면, A가 실행된다. (B는 실행x)
- 규칙 2 : Priority(A) = Priority(B) 이면, A와 B는 RR 방식으로 실행된다.
- 규칙 3 : 작업이 시스템에 진입하면, 가장 높은 우선순위, 즉 맨 위의 큐에 놓여진다.
- 규칙 4 : 주어진 단계에서 시간 할당량을 소진하면(CPU 양도와 상관 없이), 우선 순위는 낮아진다.
- 규칙 5 : 일정 기간 S가 지나면, 시스템의 모든 작업을 최상위 큐로 이동시킨다.

---

## 발표 주제 : 운영체제의 종류

### 본문 발췌

- 이런 이유로 BSD Unix와 여기서 파생된 다양한 운영체제 [Lef+89; Bac86], Solaris [McD06], Windows NT 및 이후 Windows 운영체제 [CS97]를 포함한 많은 시스템이 기본 스케줄러로 MLFQ를 사용한다.

---

운영체제는 공급되는 시장에 따라 보통 **임베디드, 서버, 모바일, 데스크탑** 네 개의 시장으로 나뉘어 있다.

## 임베디드 운영체제

임베디드 시스템은 전체 자치의 일부분으로 구성되며 제어가 필요한 시스템을 위한 두뇌 역할을 하는 **특정 목적의 컴퓨터 시스템**이다.

특정 목적을 수행하는 수행하는 컴퓨터 시스템이므로 목적을 설정하고 이를 수행하는 프로그램 코드를 작성하여 메모리에 기록하고 이를 읽어 들여 동작시키는 방법이 일반적이다.

임베디드 시스템에는 `마이크로 컨트롤러`나 `DSP(digital signal processor)` 등의 프로세서 코어가 장착될 수 있다.

임베디드는 마이크로 컨트롤러보다는 규모가 크기 때문에 운영체제가 포함되기도 한다. (운영체제 없이 마이크로 컨트롤러만 내장된 임베디드도 있음). 이 운영 체제 위에 특수한 기능만을 수행하도록 응용 프로그램이 장착되어 동작하는 경향이다.

- 마이크로 컨트롤러? : 하나의 칩(직접 회로) 안에 프로세서, 메모리, 주변 장치, 입출력 기능을 모두 통합한 소형 컴퓨터
- 운영체제는 기본적으로 메모리를 많이 잡아먹으므로 마이크로 컨트롤러만으로는 무리다. 따라서 칩 밖에 많은 용량의 메모리를 장착하고 PCB(Printed Circuit Board, 인쇄회로기판)에서 연결하는 게 일반적.

### 주요 임베디드 OS

- Windows CE(=Windows Mobile) : Microsoft에서 임베디드 시스템 용으로 제작한 OS.
- VxWorks : 1990년대부터 사용되는 전통적인 임베디드 OS로 주로 성능이 낮은 시스템에 적용됐으나, 최근에는 고도의 실시간성이 필요한 시스템이나 고성능의 시스템에서도 사용될 수 있도록 개선됨
- MicroC/OS : 개인이 임베디드 OS에서 정말로 필요한 기능만을 골라 만들어낸 소형화&경량화된 OS. 주로 교육용으로 쓰인다.
- Embedded Linux : 범용 OS인 Linux를 임베디드 시스템에 맞게 소형화 및 특성화한 OS.

## 서버 운영체제

네트워크를 통해 다수의 사용자에게 서비스를 제공하거나 데이터를 관리하는 컴퓨터 시스템에 설치된 운영체제를 의미한다.

일반적인 개인용 컴퓨터의 운영체제(데스크탑 OS)와 달리 서버 OS에는 높은 성능, 안정성, 보안성, 그리고 여러 사용자와의 동시성 통신을 지원한다.

서버 OS의 주요한 역할은 하드웨어 자원을 효율적으로 관리하고, 다양한 서비스를 제공하는 데 필요한 소프트웨어를 실행하고 관리하는 것이다.

- ex) 웹 서버 OS는 웹 서버 소프트웨어를 실행하여 웹 페이지를 제공하고, 이를 위해 필요한 CPU, 메모리, 네트워크 등의 자원을 관리한다.

### 주요 서버 OS

- Windows Server (Microsoft) : 사용자 친화적인 인터페이스와 다양한 기능을 제공. Active Direct, IIS(인터넷 정보 서비스) 등의 서비스를 제공. Windows 기반의 앱과 호환성이 뛰어나지만 리눅스에 비해 상대적으로 성능이 떨어질 수 있다.
- Linux : Apache, MySQL, PHP 등의 서비스를 쉽게 설치해 사용할 수 있다. 높은 성능과 안정성을 제공한다.
  - 데비안 계열 : 데비안, 우분투, 칼리 리눅스, 구름OS 등
  - 레드햇 계열 : 레드햇 엔터프라이즈 리눅스, Cent OS, 붉은 별, Fedora, 등
- Unix : 다중 사용자, 다중 작업을 지원하는 OS. 높은 성능과 안정성, 보안성을 제공. 주로 대형 시스템에서 사용된다.
  - Solaris, AIX 등의 다양한 버전이 있다.
- macOS Server (애플) : macOS 기반의 환경에서 서버를 운영하려는 사용자에게 적합하다. 애플 하드웨어에서만 실행 가능하다.

## 모바일 운영체제

스마트폰, 태블릿 등의 모바일 기기에서 동작하는 소프트웨어 플랫폼으로, 하드웨어와 사용자 소프트웨어 사이의 인터페이스 역할을 한다.

주로 앱 실행, 데이터 저장, 네트워크 연결 등의 기능을 제공한다.

### 주요 모바일 OS

- Andriod (Google) : 오픈 소스 기반 운영체제로 다양한 제조사와 모델에서 사용된다. 리눅스 커널을 사용하며 달빅 가상 머신을 통해 자바로 개발된 앱들을 실행한다.
  - 리눅스 기반이라는 말이 있지만 더 구체적으로는 리눅스의 커널을 사용하고 있는 것.
- iOS (Apple) : Apple 생태계와 강력한 통합성을 제공하며, 보안성이 높다.
- KaiOS (KaiOS Technologies) : HTML5 및 웹 표준 기술을 기반으로 한 경량화된 운영체제. 주로 저가형 기능폰 시장에서 사용된다.
- Tizen (Samsung Electronics, Linux Foundation) : 다양한 기기에 적용 가능한 오픈 소스 기반 운영체제. IoT 기기와의 연동이 용이하다.
- Windows Phone (Microsoft) : 윈도우 플랫폼과의 통합성을 강조했으나, 현재는 지원 중다노댔다.

## 데스트탑 운영체제

테스크탑 컴퓨터에서 사용하도록 설계된 운영 체제다.

한 번에 한 명의 사용자가 사용하도록 고안됐으며, 일반적으로 모바일 장치나 서버용으로 설계된 운영 체제보다 더 강력하고 기능이 풍부하다.

데스크탑 운영체제는 워드 프로세싱 및 미디어 재생과 같은 작업에 사용할 수 있는 다양한 기능과 응용 프로그램을 제공한다.

- 특징 : GUI(주로 데스크탑 운영체제에서 지원), 멀티태스킹, 파일 관리, 다양한 응용 프로그램, 보안, 업데이트 관리

### 주요 데스크탑 OS

- Windows (Microsoft)
- macOS
- Linux
- Chrome OS (Google) : 구글이 리눅스 커널을 기반으로 개발. 주로 크롬북에 사용됨
- Unix
  - AT&T System V : 벨 연구소/AT&T가 개발한 상업용 Unix 계열. System V Release 4는 Solaris에 큰 영향을 줌.
  - BSD : FreeBSD, Darwin(macOS), OpenBSD, NetBSD, DragonFly BSD 및 SunOS 등이 BSD 계열 Unix. 하지만 Unix 상표권이 없어 `Unix`가 아닌 `Unix 계열`로 분류된다.
  - Solaris : 초기 SunOS는 BSD 계열, 이후 System V와 통합되어 Solaris로 발전

## 자료 출처

- [Operating-SystemOS-4-종류-443-Linux](https://latteart.tistory.com/entry/Operating-SystemOS-4-%EC%A2%85%EB%A5%98-443-Linux)
- [서버-OS의-구조-및-이해-운영](https://tech-teller-com.tistory.com/entry/%EC%84%9C%EB%B2%84-OS%EC%9D%98-%EA%B5%AC%EC%A1%B0-%EB%B0%8F-%EC%9D%B4%ED%95%B4-%EC%9A%B4%EC%98%81)
- [안드로이드와 리눅스](https://eu4ng.tistory.com/28)
- [서버OS의 종류, 물리서버, 클라우드 서버의 특징 및 차이점](https://sm-lee2026210.tistory.com/entry/%ED%8C%8C%ED%8A%B8-%EA%B3%BC%EC%A0%9C-%EC%84%9C%EB%B2%84OS)
- [데스크탑 운영체제란?](https://jkcb.tistory.com/63/)
- [OS의 종류](https://blog.naver.com/ncloud24/221196787176)
